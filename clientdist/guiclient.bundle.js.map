{"version":3,"sources":["webpack:///webpack/bootstrap 6a375cac8557c6c2927d","webpack:///./src/client.tsx","webpack:///external \"jQuery\"","webpack:///webpack:///webpack/universalModuleDefinition","webpack:///webpack:/webpack/bootstrap a4469015be7ee1967645","webpack:///webpack:///lib/all.ts","webpack:///webpack:///lib/otarray.ts","webpack:///webpack:///lib/ottypes.ts","webpack:///webpack:///lib/otclientengine.ts","webpack:///webpack:///lib/otcomposite.ts","webpack:///webpack:///lib/otmap.ts","webpack:///webpack:///lib/otcounter.ts","webpack:///webpack:///lib/otserverengine.ts","webpack:///webpack:/webpack/bootstrap 5eeb9f8b798a1820ab78","webpack:///webpack:///lib/oteditutil.ts","webpack:///webpack:/external \"@terrencecrowley/ot-js\"","webpack:///webpack:/external \"diff-match-patch\"","webpack:///./~/@terrencecrowley/ot-editutil/~/diff-match-patch/index.js","webpack:///external \"React\"","webpack:///external \"ReactDOM\"","webpack:///./src/board.ts","webpack:///./src/components/app.tsx","webpack:///./src/components/navbar.tsx","webpack:///./src/components/boardview.tsx","webpack:///./src/components/message.tsx","webpack:///./src/components/chat.tsx"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACtCA,gCAA4B;AAC5B,iCAA6C;AAC7C,kCAAoD;AACpD,oCAA+B;AAC/B,uCAAsC;AACtC,oCAAiC;AACjC,oCAA4C;AAE5C,oDAAmD;AACnD,sBAAqB,EAAO,EAAE,KAAU,EAAE,GAAQ;KAC1C,EAAE,EAAC,gBAAgB,IAAI,EAAE,CAAC,CAAC,CAAC;SACxB,EAAE,CAAC,cAAc,GAAG,KAAK,CAAC;SAC1B,EAAE,CAAC,YAAY,GAAG,GAAG,CAAC;KAC1B,CAAC;KAAC,IAAI,CAAC,EAAE,EAAC,EAAE,CAAC,iBAAiB,CAAC,CAAC,CAAC;SAC7B,EAAE,CAAC,iBAAiB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;KACrC,CAAC;KAAC,IAAI,CAAC,EAAE,EAAC,EAAE,CAAC,eAAe,CAAC,CAAC,CAAC;SAC3B,IAAI,KAAK,GAAQ,EAAE,CAAC,eAAe,EAAE,CAAC;SACtC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACrB,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;SAChC,KAAK,CAAC,SAAS,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;SACpC,KAAK,CAAC,MAAM,EAAE,CAAC;KACnB,CAAC;AACL,EAAC;AAEL;KAEC;KAEC,CAAC;KAEF,kCAAS,GAAT,UAAU,IAAY;SAEpB,MAAM,CAAC,KAAK,CAAC;KACd,CAAC;KAEF,kCAAS,GAAT,UAAU,IAAY;SAEpB,MAAM,CAAC,CAAC,CAAC;KACV,CAAC;KAEF,4BAAG,GAAH,UAAI,OAAe,EAAE,CAAS;SAE5B,iBAAiB;KAClB,CAAC;KACH,qBAAC;AAAD,EAAC;AAAA,EAAC;AAEF;KAOC;SAEE,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC;SAClB,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;KACvB,CAAC;KANF,sBAAI,+BAAK;cAAT,cAAc,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;;;QAAA;KAQnC,8BAAO,GAAP;SAEE,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,oBAAoB;SACvC,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;KACvB,CAAC;KAEF,+BAAQ,GAAR;SAEE,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC,mBAAmB;SACxC,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,IAAI,EAAE,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,CAClD,CAAC;aACA,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;aACtB,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC;SAClB,CAAC;KACF,CAAC;KACH,mBAAC;AAAD,EAAC;AAAA,EAAC;AAEF;KAsCC,cAAc;KACd;SAEE,IAAI,CAAC,UAAU,GAAG,EAAG,CAAC;SACtB,IAAI,CAAC,SAAS,GAAG,EAAG,CAAC;SACrB,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;SACnB,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;SACd,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;SACjB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;SACvB,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;SACpB,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;SACxB,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;SACtB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;SAE1B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,CAAC,iDAAiD;SAC1E,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;SAChC,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;SAC3B,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;SAC3B,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;SAC7B,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;SAC3B,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;SAChC,IAAI,CAAC,qBAAqB,GAAG,KAAK,CAAC;SACnC,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;SACtB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;SAEnB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;SAC1B,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;SACzB,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;SACnB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;SACzB,IAAI,CAAC,aAAa,GAAG,IAAI,cAAc,EAAE,CAAC;SAC1C,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;SACnG,IAAI,CAAC,KAAK,GAAG,IAAI,YAAY,EAAE,CAAC;SAChC,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;KAChC,CAAC;KAEF,oBAAM,GAAN;SAEE,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CACtB,CAAC;aACA,QAAQ,CAAC,MAAM,CAAC,oBAAC,cAAQ,IAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,WAAW,EAAE,aAAa,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,eAAe,EAAE,eAAe,EAAE,YAAY,EAAE,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE,YAAY,EAAE,YAAY,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,KAAK,EAAE,IAAI,CAAC,UAAU,GAAI,EAC/Z,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;aAClC,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;SAC3B,CAAC;KACF,CAAC;KAEF,wBAAU,GAAV;SAEE,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,YAAY,CAAC,CACxB,CAAC;aACA,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;aACzB,UAAU,CAAC,cAAa,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SAChD,CAAC;KACF,CAAC;KAEF,0BAAY,GAAZ,UAAa,CAAU;SAErB,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,IAAI,CAAC,CAAC,CAC1B,CAAC;aACA,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;aACrB,IAAI,CAAC,SAAS,EAAE,CAAC;SAClB,CAAC;KACF,CAAC;KAEF,uBAAS,GAAT;SAEE,IAAI,SAAiB,CAAC;SACtB,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,WAAW,CAAC;aACtB,SAAS,GAAG,qBAAqB,CAAC;SACnC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAC5B,CAAC;aACA,EAAE,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAC5B,CAAC;iBACA,IAAI,KAAK,GAAW,CAAC,CAAC;iBACtB,IAAI,MAAM,GAAW,CAAC,CAAC;iBACvB,GAAG,CAAC,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC;qBAC/B,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,CAChE,CAAC;yBACA,MAAM,EAAE,CAAC;yBACT,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;6BAC9B,KAAK,EAAE,CAAC;qBACV,CAAC;iBACF,EAAE,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC;qBACf,SAAS,GAAG,8BAA8B,CAAC;iBAC5C,IAAI,CACJ,CAAC;qBACA,IAAI,WAAW,GAAa,EAAE,CAAC;qBAC/B,WAAW,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;qBACpC,EAAE,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC,CACnB,CAAC;yBACA,IAAI,MAAM,GAAW,MAAM,GAAG,KAAK,CAAC;yBACpC,IAAI,cAAc,GAAW,KAAK,IAAI,CAAC,GAAG,OAAO,GAAG,IAAI,CAAC;yBACzD,GAAG,CAAC,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC;6BAC/B,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAC9F,CAAC;iCACA,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;iCACvC,MAAM,EAAE,CAAC;iCACT,EAAE,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC;qCACf,WAAW,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;iCAClC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;qCACnB,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;6BACzB,CAAC;yBACF,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC;6BACb,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;qBAC5B,CAAC;qBACD,WAAW,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,KAAK,IAAI,CAAC,GAAG,iBAAiB,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC;qBAExG,SAAS,GAAG,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;iBAClC,CAAC;aACF,CAAC;aACD,IAAI;iBACH,SAAS,GAAG,sBAAsB,CAAC;SACrC,CAAC;SACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC;aAC3B,SAAS,GAAG,4BAA4B,CAAC;SAC1C,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,eAAe,IAAI,IAAI,CAAC,aAAa,CAAC;aACnD,SAAS,GAAG,0BAA0B,CAAC;SACxC,IAAI;aACH,SAAS,GAAG,qBAAqB,CAAC;SAEnC,8BAA8B;SAC9B,EAAE,CAAC,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC,CAC7B,CAAC;aACA,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;aACxB,IAAI,CAAC,UAAU,EAAE,CAAC;SACnB,CAAC;KACF,CAAC;KAEF,2BAAa,GAAb;SAEC,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CACvB,CAAC;aACA,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,CAC9F,CAAC;iBACA,IAAI,QAAQ,GAA2B,IAAI,EAAE,CAAC,mBAAmB,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;iBACtG,IAAI,OAAO,GAAqB,IAAI,EAAE,CAAC,aAAa,CAAC,qBAAqB,CAAC,CAAC;iBAC5E,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAE,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAE,CAAC,CAAC;iBAClE,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBAC7B,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;iBACrC,IAAI,CAAC,SAAS,EAAE,CAAC;aAClB,CAAC;SACF,CAAC;KACF,CAAC;KAED,wBAAU,GAAV,UAAW,CAAS;SAElB,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CACvB,CAAC;aACA,IAAI,QAAQ,GAA2B,IAAI,EAAE,CAAC,mBAAmB,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;aACtG,IAAI,QAAQ,GAAuB,IAAI,EAAE,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;aAClE,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAE,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAE,EAAG,CAAE,CAAE,CAAC,CAAC;aACrE,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAE,EAAE,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAE,CAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAE,CAAE,CAAE,CAAC,CAAC;aAClE,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aAC9B,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;aACrC,IAAI,CAAC,SAAS,EAAE,CAAC;SAClB,CAAC;KACF,CAAC;KAEF,yBAAW,GAAX,UAAY,CAAS;SAEnB,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,KAAK,CAAC,CAAC,CACxB,CAAC;aACA,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;aAClB,IAAI,CAAC,aAAa,EAAE,CAAC;aACrB,IAAI,CAAC,UAAU,EAAE,CAAC;SACnB,CAAC;KACF,CAAC;KAEF,oBAAM,GAAN;SAEE,IAAI,CAAC,GAAW,EAAE,CAAC;SACnB,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,EAAE,CAAC,CAC9B,CAAC;aACA,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,QAAQ,GAAG,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC;aACnE,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC;iBAC1B,CAAC,IAAI,GAAG,GAAG,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC;aACnC,CAAC,IAAI,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC;SACrC,CAAC;SACD,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC,CACnB,CAAC;aACA,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;aACb,IAAI,CAAC,UAAU,EAAE,CAAC;SACnB,CAAC;KACF,CAAC;KAEF,0BAAY,GAAZ,UAAa,CAAS,EAAE,cAAuB,EAAE,YAAqB;SAEpE,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;SACnB,EAAE,CAAC,CAAC,cAAc,KAAK,SAAS,CAAC;aAChC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;SACtC,EAAE,CAAC,CAAC,YAAY,KAAK,SAAS,CAAC;aAC9B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;SAClC,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,KAAK,IAAI,CAAC,SAAS;gBACxC,IAAI,CAAC,UAAU,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc;gBACrD,IAAI,CAAC,UAAU,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,CAAC,CACtD,CAAC;aACA,IAAI,CAAC,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC;aAC1B,WAAW,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;SACtE,CAAC;KACF,CAAC;KAEF,yBAAW,GAAX;SAEE,MAAM,CAAC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC;KAClC,CAAC;KAEF,oBAAM,GAAN;SAEE,UAAU,CAAE,cAAa,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;KAC9D,CAAC;KAEF,wBAAU,GAAV;SAEE,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,KAAK,GAAG,CAAC;aACtC,IAAI,CAAC,cAAc,GAAG,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;SAC5D,IAAI;aACH,IAAI,CAAC,cAAc,GAAG,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,kBAAkB;SAC/E,IAAI,CAAC,MAAM,EAAE,CAAC;SACd,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,KAAK,EAAE,CAAC;aAC9B,IAAI,CAAC,QAAQ,EAAE,CAAC;SACjB,IAAI;aACH,IAAI,CAAC,UAAU,EAAE,CAAC;SACnB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;SAC1B,IAAI,CAAC,UAAU,EAAE,CAAC;SAClB,IAAI,CAAC,MAAM,EAAE,CAAC;KACf,CAAC;KAEF,sBAAQ,GAAR;SAEE,IAAI,CAAC,WAAW,EAAE,CAAC;SACnB,IAAI,CAAC,YAAY,EAAE,CAAC;SACpB,IAAI,CAAC,UAAU,EAAE,CAAC;SAClB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;SACzB,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;SACnB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;SACzB,IAAI,CAAC,UAAU,GAAG,EAAG,CAAC;SACtB,IAAI,CAAC,SAAS,GAAG,EAAG,CAAC;SACrB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;SACtB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;SACnB,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;SAC/B,IAAI,CAAC,UAAU,EAAE,CAAC;KACnB,CAAC;KAEF,wBAAU,GAAV;SAEE,IAAI,CAAC,QAAQ,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAC;SAChC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,uBAAuB;SAC/D,IAAI,CAAC,UAAU,EAAE,CAAC;KACnB,CAAC;KAEF,yBAAW,GAAX,UAAY,EAAU;SAEpB,2BAA2B;SAC3B,+CAA+C;SAC/C,uCAAuC;SACvC,qCAAqC;SACrC,0BAA0B;SAC1B,4DAA4D;SAC5D,qDAAqD;SACrD,+BAA+B;SAC/B,+CAA+C;SAC/C,uCAAuC;SACvC,qCAAqC;SACrC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAC9B,CAAC;aACA,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;aACzC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;SAC5B,CAAC;SACD,IAAI;aACH,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;SAC5B,IAAI,CAAC,UAAU,EAAE,CAAC;KACnB,CAAC;KAEF,qDAAqD;KACrD,oBAAM,GAAN,UAAO,KAAa,EAAE,MAAY;SAEhC,MAAM,CAAC,CAAC,KAAK,CAAC,CACd,CAAC;aACA,KAAK,OAAO;iBACX,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,aAAa,CAAC,CACzB,CAAC;qBACA,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;qBAC1B,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC;0BACxB,IAAI,CAAC,UAAS,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;0BACxD,IAAI,CAAC,cAAa,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;0BAC3C,MAAM,CAAC,cAAa,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;iBACrD,CAAC;iBACD,KAAK,CAAC;aACP,KAAK,SAAS;iBACb,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;iBACxB,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC;qBACzB,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,oDAAoD,CAAC,CAAC;iBACjF,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC;qBAC3B,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,8CAA8C,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;iBACnG,IAAI,CACJ,CAAC;qBACA,IAAI,WAAW,GAAe,MAAM,CAAC,QAAQ,CAAC;qBAC9C,IAAI,OAAO,GAAQ,CAAC,CAAC,WAAW,CAAC,CAAC;qBAClC,OAAO,CAAC,KAAK,EAAE,CAAC;qBAChB,EAAE,CAAC,CAAC,WAAW,CAAC,MAAM,IAAI,CAAC,CAAC;yBAC3B,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;qBAC5E,IAAI;yBACH,sDAAsD;yBACtD,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC;6BACzB,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;iBAC9F,CAAC;iBACD,KAAK,CAAC;aACP,KAAK,MAAM;iBACV,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;iBACzB,KAAK,CAAC;aACP,KAAK,UAAU;iBACd,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;iBAC3B,KAAK,CAAC;SACR,CAAC;SACD,IAAI,CAAC,SAAS,EAAE,CAAC;KAClB,CAAC;KAEF,sBAAQ,GAAR,UAAS,KAAa,EAAE,MAAY;SAElC,MAAM,CAAC,CAAC,KAAK,CAAC,CACd,CAAC;aACA,KAAK,OAAO;iBACX,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,eAAe,CAAC,CAC3B,CAAC;qBACA,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;qBAC5B,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;qBAChC,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;qBAC3B,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC;0BAC5B,IAAI,CAAC,UAAS,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;0BAC1D,IAAI,CAAC,cAAa,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;0BAC7C,MAAM,CAAC,cAAa,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;iBACtD,CAAC;iBACD,KAAK,CAAC;aACP,KAAK,SAAS;iBACb,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;iBACxB,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC;qBACzB,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,sDAAsD,CAAC,CAAC;iBACnF,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC;qBAC3B,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,gDAAgD,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;iBACrG,IAAI,CACJ,CAAC;qBACA,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;qBAC/B,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;qBAC3B,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC,UAAU,CAAC;qBACxC,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC;qBAC/C,IAAI,CAAC,MAAM,EAAE,CAAC;qBACd,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,4BAA4B,GAAG,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;iBACrF,CAAC;iBACD,IAAI,CAAC,QAAQ,EAAE,CAAC;iBAChB,KAAK,CAAC;aACP,KAAK,MAAM;iBACV,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;iBACzB,KAAK,CAAC;aACP,KAAK,UAAU;iBACd,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;iBAC7B,KAAK,CAAC;SACR,CAAC;SACD,IAAI,CAAC,SAAS,EAAE,CAAC;SACjB,CAAC,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,aAAa,CAAC,CAAC;KACxG,CAAC;KAEF,oBAAM,GAAN,UAAO,KAAa,EAAE,MAAY;SAEhC,MAAM,CAAC,CAAC,KAAK,CAAC,CACd,CAAC;aACA,KAAK,OAAO;iBACX,CAAC;qBACA,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,cAAc,KAAK,EAAE,CAAC,CACvD,CAAC;yBACA,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;yBAC1B,CAAC,CAAC,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,cAAc,CAAC;8BACpD,IAAI,CAAC,UAAS,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;8BACxD,IAAI,CAAC,cAAa,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;8BAC3C,MAAM,CAAC,cAAa,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;qBACpD,CAAC;iBACF,CAAC;iBACD,KAAK,CAAC;aACP,KAAK,SAAS;iBACb,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;iBACxB,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,KAAK,SAAS,CAAC;qBAC/B,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,oDAAoD,CAAC,CAAC;iBACjF,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC,CAC5B,CAAC;qBACA,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC,CACvB,CAAC;yBACA,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;yBAC1B,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;qBAChC,CAAC;qBACD,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,8CAA8C,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;iBACnG,CAAC;iBACD,IAAI,CACJ,CAAC;qBACA,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;qBAC3B,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;qBAC/B,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;qBAChC,IAAI,CAAC,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;qBACvC,IAAI,CAAC,YAAY,GAAG,IAAI,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;qBAClG,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,IAAI,EAAE,IAAI,MAAM,CAAC,QAAQ,CAAC;yBAC1C,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;qBACnC,IAAI;yBACH,IAAI,CAAC,aAAa,EAAE,CAAC;qBACtB,IAAI,CAAC,SAAS,EAAE,CAAC;iBAClB,CAAC;iBACD,KAAK,CAAC;aACP,KAAK,MAAM;iBACV,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;iBACzB,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;iBAChC,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;iBAC3B,KAAK,CAAC;aACP,KAAK,UAAU;iBACd,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;iBAC3B,KAAK,CAAC;SACR,CAAC;SACD,IAAI,CAAC,SAAS,EAAE,CAAC;SACjB,CAAC,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,aAAa,CAAC,CAAC;KACxG,CAAC;KAEF,qBAAO,GAAP,UAAQ,KAAa,EAAE,MAAY;SAEjC,MAAM,CAAC,CAAC,KAAK,CAAC,CACd,CAAC;aACA,KAAK,OAAO;iBACX,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,CAAC,CAClC,CAAC;qBACA,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,kBAAkB,CAAC,CAC9B,CAAC;yBACA,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;yBAC/B,IAAI,IAAI,GAA2B,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,CAAC;yBAClE,IAAI,IAAI,GAAQ,EAAE,UAAU,EAAE,IAAI,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC;yBACrE,CAAC,CAAC,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,cAAc,EACtD;6BACC,QAAQ,EAAE,MAAM;6BAChB,aAAa,EAAE,iCAAiC;6BAChD,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;6BAC5B,aAAa,EAAE,KAAK;6BACpB,UAAU,EAAE,MAAM;0BAClB,CAAC;8BACD,IAAI,CAAC,UAAS,IAAI,IAAI,MAAM,CAAC,OAAO,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;8BAC9D,IAAI,CAAC,cAAa,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;8BAC5C,MAAM,CAAC,cAAa,MAAM,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;qBAC1D,CAAC;iBACF,CAAC;iBACD,IAAI,CACJ,CAAC;qBACA,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,qBAAqB,CAAC,CACjC,CAAC;yBACA,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;yBAClC,CAAC,CAAC,IAAI,CAAC,6BAA6B,GAAG,IAAI,CAAC,cAAc,EACzD;6BACC,QAAQ,EAAE,MAAM;6BAChB,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,UAAU,EAAE,IAAI,CAAC,YAAY,CAAC,QAAQ;iCACxD,WAAW,EAAE,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,GAAG,CAAC,EAAE,CAAC;6BAC1D,aAAa,EAAE,iCAAiC;6BAChD,aAAa,EAAE,KAAK;6BACpB,UAAU,EAAE,MAAM;0BAClB,CAAC;8BACD,IAAI,CAAC,UAAS,IAAI,IAAI,MAAM,CAAC,OAAO,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;8BACjE,IAAI,CAAC,cAAa,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;8BAC5C,MAAM,CAAC,cAAa,MAAM,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC;qBAC7D,CAAC;iBACF,CAAC;iBACD,KAAK,CAAC;aACP,KAAK,cAAc,CAAC;aACpB,KAAK,iBAAiB;iBACrB,CAAC;qBACA,IAAI,OAAO,GAAW,MAAM,GAAG,MAAM,CAAC,MAAM,GAAG,SAAS,CAAC;qBACzD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;qBAC/B,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;qBAC3B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;qBACxB,EAAE,CAAC,CAAC,OAAO,KAAK,SAAS,CAAC,CAC1B,CAAC;yBACA,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,oDAAoD,CAAC,CAAC;qBACjF,CAAC;qBACD,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,IAAI,EAAE,CAAC,YAAY,CAAC,CACpC,CAAC;yBACA,MAAM,CAAC,CAAC,OAAO,CAAC,CAChB,CAAC;6BACA,KAAK,CAAC;iCACL,oBAAoB;iCACpB,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;iCAChC,KAAK,CAAC;6BACP,KAAK,EAAE,CAAC,iBAAiB;iCACxB,sBAAsB;iCACtB,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,CAAC;iCAC/B,KAAK,CAAC;6BACP,KAAK,EAAE,CAAC,cAAc;iCACrB,6FAA6F;iCAC7F,KAAK,CAAC;6BACP,KAAK,EAAE,CAAC,iBAAiB;iCACxB,4FAA4F;iCAC5F,2BAA2B;iCAC3B,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE,CAAC;iCACjC,KAAK,CAAC;6BACP;iCACC,yCAAyC;iCACzC,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,CAAC;yBACjC,CAAC;yBACD,IAAI,CAAC,UAAU,EAAE,CAAC;qBACnB,CAAC;qBACD,IAAI,CACJ,CAAC;yBACA,IAAI,MAAM,GAAe,MAAM,CAAC,QAAQ,CAAC;yBACzC,EAAE,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAChC,CAAC;6BACA,GAAG,CAAC,CAAC,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAC9C,CAAC;iCACA,IAAI,CAAC,GAA2B,EAAE,CAAC,mBAAmB,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;iCACtF,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;6BAChC,CAAC;6BACD,IAAI,MAAM,GAAQ,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;6BAC9C,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CACnB,CAAC;iCACA,IAAI,MAAM,GAAQ,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;iCAC5E,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC;iCACpD,IAAI,EAAE,GAAW,MAAM,IAAI,MAAM,CAAC,cAAc,GAAG,MAAM,CAAC,cAAc,GAAG,SAAS,CAAC;iCACrF,IAAI,EAAE,GAAW,MAAM,IAAI,MAAM,CAAC,YAAY,GAAG,MAAM,CAAC,YAAY,GAAG,EAAE,CAAC;iCAC1E,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;6BAC3C,CAAC;6BACD,EAAE,CAAC,CAAC,MAAM,CAAC,qBAAqB,CAAC,CAAC,CAClC,CAAC;iCACA,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,qBAAqB,CAAC,CAAC;iCAChD,2EAA2E;iCAC3E,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC;qCAC1C,IAAI,CAAC,aAAa,EAAE,CAAC;6BACvB,CAAC;6BACD,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CACnB,CAAC;iCACA,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;iCAChC,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;qCACjB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;6BACzC,CAAC;6BACD,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,mBAAmB,GAAG,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;6BACpF,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;6BACrB,IAAI,CAAC,UAAU,EAAE,CAAC;yBACnB,CAAC;yBACD,IAAI;6BACH,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;yBACvB,IAAI,CAAC,SAAS,EAAE,CAAC;qBAClB,CAAC;iBACF,CAAC;iBACD,KAAK,CAAC;aACP,KAAK,MAAM;iBACV,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE,CAAC;iBACjC,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;iBAChC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;iBACzB,KAAK,CAAC;aACP,KAAK,eAAe;iBACnB,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;iBAChC,KAAK,CAAC;aACP,KAAK,kBAAkB;iBACtB,IAAI,CAAC,qBAAqB,GAAG,KAAK,CAAC;iBACnC,KAAK,CAAC;SACR,CAAC;SACD,IAAI,CAAC,SAAS,EAAE,CAAC;KAClB,CAAC;KAEF,sBAAQ,GAAR,cAAmB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;KAC1C,wBAAU,GAAV,cAAqB,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;KAC9C,sBAAQ,GAAR,cAAmB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;KAC1C,uBAAS,GAAT,cAAoB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;KAE5C,wBAAU,GAAV,cAAqB,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;KAC/C,0BAAY,GAAZ,cAAuB,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;KACnD,wBAAU,GAAV,cAAqB,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;KAC/C,yBAAW,GAAX,cAAsB,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;KAEjD,kBAAI,GAAJ;SAEE,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CACvB,CAAC;aACA,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;aACtB,IAAI,CAAC,QAAQ,EAAE,CAAC;SACjB,CAAC;SACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;aAC3B,IAAI,CAAC,SAAS,EAAE,CAAC;SAClB,IAAI,CAAC,MAAM,EAAE,CAAC;KACf,CAAC;KACH,UAAC;AAAD,EAAC;AAAA,EAAC;AAEF,KAAI,MAAM,GAAQ,IAAI,CAAC;AAGvB;KAEC,MAAM,CAAC,QAAQ,EAAE,CAAC;AACnB,EAAC;AAED;KAEC,MAAM,CAAC,UAAU,EAAE,CAAC;AACrB,EAAC;AAED,uBAAsB,KAAa;KAElC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AAC1B,EAAC;AAED,2BAA0B,EAAO;KAEhC,MAAM,CAAC,UAAU,GAAG,EAAE,CAAC;AACxB,EAAC;AAED,0BAAyB,OAAe,EAAE,CAAS,EAAE,CAAS;KAE7D,EAAE,CAAC,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,CACzB,CAAC;SACA,IAAI,MAAM,GAAQ,MAAM,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;SAChD,IAAI,OAAO,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;SAC/D,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,IAAI,CAAC,IAAI,MAAM,CAAC,cAAc,IAAI,CAAC,IAAI,MAAM,CAAC,YAAY,CAAC,CACjF,CAAC;aACA,IAAI,IAAI,GAA2B,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;aACjF,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;aACzC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CACpB,CAAC;iBACA,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;iBACnC,MAAM,CAAC,SAAS,EAAE,CAAC;aACpB,CAAC;SACF,CAAC;KACF,CAAC;KACD,MAAM,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACpC,EAAC;AAED,uBAAsB,OAAe;KAEpC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;AAC7B,EAAC;AAED,wBAAuB,EAAU;KAEhC,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AACxB,EAAC;AAED;KAEC,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;KACnB,MAAM,CAAC,UAAU,EAAE,CAAC;AACrB,EAAC;AAGD,EAAC,CAAG,UAAU,CAAE,CAAC;;;;;;;AChvBjB,yB;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,Q;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;AACA;AACA;AACA,qBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAuD,0CAA0C;AACjG;AACA,6DAA2D,iCAAiC;AAC5F,gEAA8D,iCAAiC;AAC/F,6DAA2D,iCAAiC;AAC5F,gEAA8D,iCAAiC;AAC/F,gEAA8D,oCAAoC;AAClG,2EAAyE,kEAAkE;AAC3I,wEAAsE,kEAAkE;AACxI;AACA,6DAA2D,iBAAiB;AAC5E,2DAAyD,+CAA+C;AACxG,iEAA+D,yEAAyE;AACxI;AACA,mEAAiE,iCAAiC,kCAAkC;AACpI,0DAAwD,yBAAyB,UAAU,yBAAyB;AACpH,8DAA4D;AAC5D,uBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;AACA;AACA;AACA;AACA;AACA,qEAAmE,iBAAiB;AACpF,wDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAsD,UAAU;AAChE,0DAAwD,iBAAiB;AACzE;AACA,GAAC;AACD;AACA;AACA;AACA;AACA;AACA,oEAAkE,gBAAgB;AAClF,uDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA,qBAAmB,SAAS;AAC5B;AACA,qBAAmB,sBAAsB;AACzC;AACA,uBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAoB;AACpB;AACA;AACA;AACA;AACA,gBAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAoB;AACpB,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAgE,sFAAsF,EAAE;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAmF;AACnF;AACA;AACA,qFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAqB;AACrB;AACA;AACA;AACA;AACA,0BAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA8B,oCAAoC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAwD,YAAY;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,mDAAiD,oCAAoC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,kDAAgD,mCAAmC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iCAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC76BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAS;AACT;AACA;AACA,OAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;AACA;;;;;;;ACjMA;AACA;AACA;AACA,qBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAA+B;AAC/B,mCAAiC;AACjC,mCAAiC;AACjC,iCAA+B;AAC/B,oCAAkC;AAClC,8BAA4B;AAC5B,8BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAA+B,YAAY;AAC3C,sCAAoC,oBAAoB;AACxD,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA,2BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;;;;;;;ACxKA;AACA;AACA;AACA,qBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA4C,+BAA+B;AAC3E;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,gBAAgB;AACvC;AACA,+CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,mCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;;;;;;;ACvGA;AACA;AACA;AACA,qBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAgD,mCAAmC;AACnF;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,mCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;;;;;;;;;;;;;ATjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,Q;AUVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,0DAAwD;AACxD;AACA,wDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAC;AACD;;;;;;;ACzJA,0C;;;;;;ACAA,0C;;;;;;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAe,sBAAsB;AACrC;;;AAGA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,aAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA;AACA,YAAW,OAAO;AAClB,aAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;;AAEd;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,qBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU;AACV;;;AAGA;AACA;AACA;AACA,YAAW,gCAAgC;AAC3C,YAAW,gBAAgB;AAC3B;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAW,gCAAgC;AAC3C;AACA;AACA;AACA,uBAAsB;AACtB,4BAA2B;AAC3B,cAAa,QAAQ;AACrB;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,OAAO;AACZ;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,gCAAgC;AAC3C;AACA;AACA;AACA,uBAAsB;AACtB,4BAA2B;AAC3B,cAAa,QAAQ;AACrB;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK,OAAO;AACZ;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,gCAAgC;AAC3C;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,gCAAgC;AAC3C,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,kBAAkB;AAC/B,uCAAsC;AACtC;AACA;AACA,uCAAsC;AACtC;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAW,gCAAgC;AAC3C,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC,0BAAyB;AACzB,4BAA2B;AAC3B,gDAA+C,4BAA4B;AAC3E,mCAAkC,gCAAgC;AAClE;AACA;AACA,mDAAkD;AAClD;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAW,gCAAgC;AAC3C,aAAY,OAAO;AACnB;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAW,gCAAgC;AAC3C,aAAY,OAAO;AACnB;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,qCAAoC;AACpC;AACA,YAAW,gCAAgC;AAC3C,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,gCAAgC;AAC3C,aAAY,OAAO;AACnB;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,gCAAgC;AAC5C,aAAY,OAAO;AACnB;AACA;AACA;AACA,uBAAsB;AACtB,mBAAkB;AAClB;AACA,kBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,YAAY;AACpC;AACA;AACA;AACA,qBAAoB;AACpB;AACA,QAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA,YAAW,4BAA4B;AACvC,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,uCAAuC;AAClD;AACA,YAAW,uCAAuC;AAClD;AACA,YAAW,uCAAuC;AAClD;AACA,aAAY,qCAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B,8CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,wBAAuB,gCAAgC;AACvD;AACA,IAAG;AACH;AACA;AACA,wBAAuB,OAAO;AAC9B,wBAAuB,gCAAgC;AACvD,IAAG;AACH;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B,wBAAuB,gCAAgC;AACvD,IAAG;AACH;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;AACA,2BAA0B;AAC1B,uBAAsB;AACtB,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,YAAW,qCAAqC;AAChD,aAAY,qCAAqC;AACjD;AACA;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,oBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,qCAAqC;AAChD,YAAW,OAAO;AAClB,aAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,0BAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA,cAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,qCAAqC;AAChD,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC,mCAAkC;AAClC;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,qCAAqC;AAChD;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAW,qCAAqC;AAChD,aAAY,OAAO;AACnB;AACA;AACA;AACA,kBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,qCAAqC;AACjD,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAa,gCAAgC;AAC7C;AACA,cAAa,QAAQ;AACrB;AACA,cAAa,QAAQ;AACrB;AACA,cAAa,OAAO;AACpB;AACA,cAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,kBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChpEA,wB;;;;;;ACAA,2B;;;;;;ACAA,SAAQ;AACR,cAAa;AACb,YAAW;AACX,8BAA6B;AAC7B,uCAAsC;;AAEzB,cAAK,GAAW,CAAC,CAAC;AAClB,aAAI,GAAW,CAAC,CAAC;AACjB,eAAM,GAAW,CAAC,CAAC;AACnB,eAAM,GAAW,CAAC,CAAC;AACnB,aAAI,GAAW,CAAC,CAAC;AACjB,cAAK,GAAW,EAAE,CAAC;AACnB,aAAI,GAAW,EAAE,CAAC;AAClB,c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","file":"guiclient.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6a375cac8557c6c2927d","import * as $ from \"jquery\";\nimport * as OT from \"@terrencecrowley/ot-js\";\nimport * as OTE from \"@terrencecrowley/ot-editutil\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport * as Board from \"./board\";\nimport { ReactApp } from \"./components/app\";\n\n// Helper function for setting range of a textarea.\nfunction selectRange(el: any, start: any, end: any) {\n        if('selectionStart' in el) {\n            el.selectionStart = start;\n            el.selectionEnd = end;\n        } else if(el.setSelectionRange) {\n            el.setSelectionRange(start, end);\n        } else if(el.createTextRange) {\n            let range: any = el.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        }\n    }\n\nclass BrowserContext implements OT.IExecutionContext\n{\n\tconstructor()\n\t\t{\n\t\t}\n\n\tflagIsSet(flag: string): boolean\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\tflagValue(flag: string): number\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\tlog(verbose: number, s: string): void\n\t\t{\n\t\t\t// logMessage(s);\n\t\t}\n};\n\nclass SpeedManager\n{\n\tprivate _Speed: number;\n\tprivate _SlowCounter: number;\n\n\tget speed() { return this._Speed; }\n\n\tconstructor()\n\t\t{\n\t\t\tthis._Speed = 100;\n\t\t\tthis._SlowCounter = 0;\n\t\t}\n\n\tspeedUp(): void\n\t\t{\n\t\t\tthis._Speed = 100;\t// Speed up quickly.\n\t\t\tthis._SlowCounter = 0;\n\t\t}\n\n\tslowDown(): void\n\t\t{\n\t\t\tthis._SlowCounter++; // Slow down slowly\n\t\t\tif (this._SlowCounter == 10 && this._Speed < 5000)\n\t\t\t{\n\t\t\t\tthis._SlowCounter = 0;\n\t\t\t\tthis._Speed *= 2;\n\t\t\t}\n\t\t}\n};\n\nclass App\n{\n\tUserName: string;\n\tUrl: string;\n\tStatus: string;\n\tusersValue: any;\t// map of <userID, userName> pairs\n\tchatArray: any;\t\t// array of [userID, chat string] tuples\n\n\telTextArea: any;\n\ttextValue: string;\n\tselectionStart: number;\n\tselectionEnd: number;\n\n\tisConnected: boolean;\n\tisSessionReachable: boolean;\n\tisSessionFull: boolean;\n\tisPendingList: boolean;\n\tisPendingCreate: boolean;\n\tisPendingJoin: boolean;\n\tisPendingSendEdits: boolean;\n\tisPendingReceiveEdits: boolean;\n\tisAutoClient: boolean;\n\tisChatOn: boolean;\n\tnChatSeen: number;\n\n\tcurrentSession: string;\n\tclientID: string;\n\tclientEngine: OT.OTClientEngine;\n\tclientContext: BrowserContext;\n\tEditUtil: OTE.OTEditUtil;\n\tspeed: SpeedManager;\n\n\t// For rendering\n\tdoNeedRender: boolean;\n\n\t// Actual board\n\tboard: Board.Board;\n\n\t// constructor\n\tconstructor()\n\t\t{\n\t\t\tthis.usersValue = { };\n\t\t\tthis.chatArray = [ ];\n\t\t\tthis.UserName = '';\n\t\t\tthis.Url = '';\n\t\t\tthis.Status = '';\n\t\t\tthis.elTextArea = null;\n\t\t\tthis.textValue = '';\n\t\t\tthis.selectionStart = 0;\n\t\t\tthis.selectionEnd = 0;\n\t\t\tthis.doNeedRender = false;\n\n\t\t\tthis.isConnected = true; // After all, we did successfully reach the page.\n\t\t\tthis.isSessionReachable = false;\n\t\t\tthis.isSessionFull = false;\n\t\t\tthis.isPendingList = false;\n\t\t\tthis.isPendingCreate = false;\n\t\t\tthis.isPendingJoin = false;\n\t\t\tthis.isPendingSendEdits = false;\n\t\t\tthis.isPendingReceiveEdits = false;\n\t\t\tthis.isChatOn = false;\n\t\t\tthis.nChatSeen = 0;\n\n\t\t\tthis.isAutoClient = false;\n\t\t\tthis.currentSession = '';\n\t\t\tthis.clientID = '';\n\t\t\tthis.clientEngine = null;\n\t\t\tthis.clientContext = new BrowserContext();\n\t\t\tthis.EditUtil = new OTE.OTEditUtil(this.clientContext, this.currentSession, this.clientID, 'text');\n\t\t\tthis.speed = new SpeedManager();\n\t\t\tthis.board = new Board.Board();\n\t\t}\n\n\trender(): void\n\t\t{\n\t\t\tif (this.doNeedRender)\n\t\t\t{\n\t\t\t\tReactDOM.render(<ReactApp board={this.board} clickSquare={clickSquareCB} name={this.UserName} url={this.Url} status={this.Status} captureElementCB={captureElementCB} contentChangeCB={contentChangeCB} nameChangeCB={nameChangeCB} newCB={newCB} submitChatCB={submitChatCB} chatCB={chatCB} isChatOn={this.isChatOn} nChatSeen={this.nChatSeen} clientID={this.clientID} chatArray={this.chatArray} users={this.usersValue} />,\n\t\t\t\t\tdocument.getElementById(\"root\"));\n\t\t\t\tthis.doNeedRender = false;\n\t\t\t}\n\t\t}\n\n\tneedRender(): void\n\t\t{\n\t\t\tif (! this.doNeedRender)\n\t\t\t{\n\t\t\t\tthis.doNeedRender = true;\n\t\t\t\tsetTimeout(function() { theApp.render(); }, 1);\n\t\t\t}\n\t\t}\n\n\tsetConnected(b: boolean): void\n\t\t{\n\t\t\tif (this.isConnected != b)\n\t\t\t{\n\t\t\t\tthis.isConnected = b;\n\t\t\t\tthis.setStatus();\n\t\t\t}\n\t\t}\n\n\tsetStatus(): void\n\t\t{\n\t\t\tlet newStatus: string;\n\t\t\tif (! this.isConnected)\n\t\t\t\tnewStatus = \"Server unreachable.\";\n\t\t\telse if (this.isInSession())\n\t\t\t{\n\t\t\t\tif (this.isSessionReachable)\n\t\t\t\t{\n\t\t\t\t\tlet nAnon: number = 0;\n\t\t\t\t\tlet nOther: number = 0;\n\t\t\t\t\tfor (var cid in this.usersValue)\n\t\t\t\t\t\tif (this.usersValue.hasOwnProperty(cid) && cid != this.clientID)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnOther++;\n\t\t\t\t\t\t\tif (this.usersValue[cid] == '')\n\t\t\t\t\t\t\t\tnAnon++;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (nOther == 0)\n\t\t\t\t\t\tnewStatus = \"Connected, no other authors.\";\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlet statusBuild: string[] = [];\n\t\t\t\t\t\tstatusBuild.push('Connected with ');\n\t\t\t\t\t\tif (nOther > nAnon)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet nNames: number = nOther - nAnon;\n\t\t\t\t\t\t\tlet sFinalCombiner: string = nAnon == 0 ? ' and ' : ', ';\n\t\t\t\t\t\t\tfor (var cid in this.usersValue)\n\t\t\t\t\t\t\t\tif (this.usersValue.hasOwnProperty(cid) && cid != this.clientID && this.usersValue[cid] != '')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstatusBuild.push(this.usersValue[cid]);\n\t\t\t\t\t\t\t\t\tnNames--;\n\t\t\t\t\t\t\t\t\tif (nNames == 1)\n\t\t\t\t\t\t\t\t\t\tstatusBuild.push(sFinalCombiner);\n\t\t\t\t\t\t\t\t\telse if (nNames > 1)\n\t\t\t\t\t\t\t\t\t\tstatusBuild.push(', ');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (nAnon > 0)\n\t\t\t\t\t\t\t\tstatusBuild.push(' and ');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatusBuild.push(nAnon == 0 ? '.' : (nAnon == 1 ? 'one other user.' : String(nAnon) + ' other users.'));\n\n\t\t\t\t\t\tnewStatus = statusBuild.join('');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnewStatus = \"Session unavailable.\";\n\t\t\t}\n\t\t\telse if (this.isSessionFull)\n\t\t\t\tnewStatus = \"Session full, please wait.\";\n\t\t\telse if (this.isPendingCreate || this.isPendingJoin)\n\t\t\t\tnewStatus = \"Connecting to session...\";\n\t\t\telse\n\t\t\t\tnewStatus = \"No current session.\";\n\n\t\t\t// Only re-render as necessary\n\t\t\tif (newStatus != this.Status)\n\t\t\t{\n\t\t\t\tthis.Status = newStatus;\n\t\t\t\tthis.needRender();\n\t\t\t}\n\t\t}\n\n\tshareUserName(): void\n\t{\n\t\tif (this.isInSession())\n\t\t{\n\t\t\tif (this.usersValue[this.clientID] == null || this.usersValue[this.clientID] != this.UserName)\n\t\t\t{\n\t\t\t\tlet editRoot: OT.OTCompositeResource = new OT.OTCompositeResource(this.currentSession, this.clientID);\n\t\t\t\tlet editMap: OT.OTMapResource = new OT.OTMapResource('WellKnownName_users');\n\t\t\t\teditMap.edits.push([ OT.OpMapSet, this.clientID, this.UserName ]);\n\t\t\t\teditRoot.edits.push(editMap);\n\t\t\t\tthis.clientEngine.addLocal(editRoot);\n\t\t\t\tthis.fireEdits();\n\t\t\t}\n\t\t}\n\t}\n\n\tsubmitChat(s: string): void\n\t\t{\n\t\t\tif (this.isInSession())\n\t\t\t{\n\t\t\t\tlet editRoot: OT.OTCompositeResource = new OT.OTCompositeResource(this.currentSession, this.clientID);\n\t\t\t\tlet editChat: OT.OTArrayResource = new OT.OTArrayResource('chat');\n\t\t\t\teditChat.edits.push([ OT.OpRetain, this.chatArray.length, [ [ ] ] ]);\n\t\t\t\teditChat.edits.push([ OT.OpInsert, 1, [ [ this.clientID, s ] ] ]);\n\t\t\t\teditRoot.edits.push(editChat);\n\t\t\t\tthis.clientEngine.addLocal(editRoot);\n\t\t\t\tthis.fireEdits();\n\t\t\t}\n\t\t}\n\n\tsetUserName(s: string): void\n\t\t{\n\t\t\tif (this.UserName !== s)\n\t\t\t{\n\t\t\t\tthis.UserName = s;\n\t\t\t\tthis.shareUserName();\n\t\t\t\tthis.needRender();\n\t\t\t}\n\t\t}\n\n\tsetUrl(): void\n\t\t{\n\t\t\tlet s: string = '';\n\t\t\tif (this.currentSession != '')\n\t\t\t{\n\t\t\t\ts = document.location.protocol + '//' + document.location.hostname;\n\t\t\t\tif (document.location.port)\n\t\t\t\t\ts += ':' + document.location.port;\n\t\t\t\ts += '/join/' + this.currentSession;\n\t\t\t}\n\t\t\tif (this.Url !== s)\n\t\t\t{\n\t\t\t\tthis.Url = s;\n\t\t\t\tthis.needRender();\n\t\t\t}\n\t\t}\n\n\tsetTextValue(s: string, selectionStart?: number, selectionEnd?: number): void\n\t\t{\n\t\t\tthis.textValue = s;\n\t\t\tif (selectionStart !== undefined)\n\t\t\t\tthis.selectionStart = selectionStart;\n\t\t\tif (selectionEnd !== undefined)\n\t\t\t\tthis.selectionEnd = selectionEnd;\n\t\t\tif (this.elTextArea.value !== this.textValue\n\t\t\t\t|| this.elTextArea.selectionStart != this.selectionStart\n\t\t\t\t|| this.elTextArea.selectionEnd != this.selectionEnd)\n\t\t\t{\n\t\t\t\tthis.elTextArea.value = s;\n\t\t\t\tselectRange(this.elTextArea, this.selectionStart, this.selectionEnd);\n\t\t\t}\n\t\t}\n\n\tisInSession(): boolean\n\t\t{\n\t\t\treturn this.clientEngine != null;\n\t\t}\n\n\treTick(): void\n\t\t{\n\t\t\tsetTimeout( function() { theApp.tick(); }, this.speed.speed);\n\t\t}\n\n\tInitialize(): void\n\t\t{\n\t\t\tif (document.location.pathname === \"/\")\n\t\t\t\tthis.currentSession = document.location.pathname.substr(1);\n\t\t\telse\n\t\t\t\tthis.currentSession = document.location.pathname.substr(6); // Remove \"/join/\"\n\t\t\tthis.setUrl();\n\t\t\tif (this.currentSession !== '')\n\t\t\t\tthis.fireJoin();\n\t\t\telse\n\t\t\t\tthis.fireCreate();\n\t\t\tthis.isAutoClient = false;\n\t\t\tthis.needRender();\n\t\t\tthis.reTick();\n\t\t}\n\n\tnewBoard(): void\n\t\t{\n\t\t\tthis.cancelEdits();\n\t\t\tthis.cancelCreate();\n\t\t\tthis.cancelJoin();\n\t\t\tthis.currentSession = '';\n\t\t\tthis.clientID = '';\n\t\t\tthis.clientEngine = null;\n\t\t\tthis.usersValue = { };\n\t\t\tthis.chatArray = [ ];\n\t\t\tthis.isChatOn = false;\n\t\t\tthis.nChatSeen = 0;\n\t\t\tthis.board = new Board.Board();\n\t\t\tthis.fireCreate();\n\t\t}\n\n\ttoggleChat(): void\n\t\t{\n\t\t\tthis.isChatOn = ! this.isChatOn;\n\t\t\tthis.nChatSeen = this.chatArray.length; // either now or before\n\t\t\tthis.needRender();\n\t\t}\n\n\tclickSquare(id: number): void\n\t\t{\n\t\t\t// If no square is selected\n\t\t\t//\tAND there is a piece at the clicked location\n\t\t\t//\tAND it is the color who gets to move\n\t\t\t//\tTHEN set it as the selected square\n\t\t\t// If a square is selected\n\t\t\t//\tAND the clicked square is one of the legal target squares\n\t\t\t//\tTHEN move the selected piece to the clicked square\n\t\t\t// Else If a square is selected\n\t\t\t//\tAND there is a piece at the clicked location\n\t\t\t//\tAND it is the color who gets to move\n\t\t\t//\tTHEN set it as the selected square\n\t\t\tif (this.board.isTargeted(id))\n\t\t\t{\n\t\t\t\tthis.board.move(this.board.selected, id);\n\t\t\t\tthis.board.setSelected(-1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tthis.board.setSelected(id);\n\t\t\tthis.needRender();\n\t\t}\n\n\t// events are: 'start', 'succeed', 'fail', 'complete'\n\tonList(event: string, result?: any): void\n\t\t{\n\t\t\tswitch (event)\n\t\t\t{\n\t\t\t\tcase 'start':\n\t\t\t\t\tif (! this.isPendingList)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.isPendingList = true;\n\t\t\t\t\t\t$.getJSON(\"/api/sessions\")\n\t\t\t\t\t\t\t.done(function(data) { theApp.onList('succeed', data); })\n\t\t\t\t\t\t\t.fail(function() { theApp.onList('fail'); })\n\t\t\t\t\t\t\t.always(function() { theApp.onList('complete'); });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'succeed':\n\t\t\t\t\tthis.setConnected(true);\n\t\t\t\t\tif (result.result == null)\n\t\t\t\t\t\tthis.clientContext.log(1, \"List session succeeded but expected result status.\");\n\t\t\t\t\telse if (result.result != 0)\n\t\t\t\t\t\tthis.clientContext.log(1, \"List session succeeded but result status is \" + String(result.result));\n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\tlet sessionList: Array<any> = result.sessions;\n\t\t\t\t\t\tlet $select: any = $(\"#sessions\");\n\t\t\t\t\t\t$select.empty();\n\t\t\t\t\t\tif (sessionList.length == 0)\n\t\t\t\t\t\t\t$select.append($('<option />').attr('value', \"none\").html(\"No sessions.\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t//for (let i: number = 0; i < sessionList.length; i++)\n\t\t\t\t\t\t\tfor (let i in sessionList)\n\t\t\t\t\t\t\t\t$select.append($('<option />').attr('value', (sessionList[i])[\"session_id\"]).html(\"\" + i));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'fail':\n\t\t\t\t\tthis.setConnected(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'complete':\n\t\t\t\t\tthis.isPendingList = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.setStatus();\n\t\t}\n\n\tonCreate(event: string, result?: any): void\n\t\t{\n\t\t\tswitch (event)\n\t\t\t{\n\t\t\t\tcase 'start':\n\t\t\t\t\tif (! this.isPendingCreate)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.isPendingCreate = true;\n\t\t\t\t\t\tthis.isSessionReachable = false;\n\t\t\t\t\t\tthis.isSessionFull = false;\n\t\t\t\t\t\t$.post(\"/api/sessions/create\")\n\t\t\t\t\t\t\t.done(function(data) { theApp.onCreate('succeed', data); })\n\t\t\t\t\t\t\t.fail(function() { theApp.onCreate('fail'); })\n\t\t\t\t\t\t\t.always(function() { theApp.onCreate('complete'); })\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'succeed':\n\t\t\t\t\tthis.setConnected(true);\n\t\t\t\t\tif (result.result == null)\n\t\t\t\t\t\tthis.clientContext.log(1, \"Create session succeeded but expected result status.\");\n\t\t\t\t\telse if (result.result != 0)\n\t\t\t\t\t\tthis.clientContext.log(1, \"Create session succeeded but result status is \" + String(result.result));\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.isSessionReachable = true;\n\t\t\t\t\t\tthis.isSessionFull = false;\n\t\t\t\t\t\tthis.currentSession = result.session_id;\n\t\t\t\t\t\tthis.EditUtil.resourceID = this.currentSession;\n\t\t\t\t\t\tthis.setUrl();\n\t\t\t\t\t\tthis.clientContext.log(2, \"Create session succeeded: \" + String(result.session_id));\n\t\t\t\t\t}\n\t\t\t\t\tthis.fireJoin();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'fail':\n\t\t\t\t\tthis.setConnected(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'complete':\n\t\t\t\t\tthis.isPendingCreate = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.setStatus();\n\t\t\t$(\"#scratchpad\").prop(\"readonly\", !this.isConnected || !this.isSessionReachable || this.isSessionFull);\n\t\t}\n\n\tonJoin(event: string, result?: any): void\n\t\t{\n\t\t\tswitch (event)\n\t\t\t{\n\t\t\t\tcase 'start':\n\t\t\t\t\t{\n\t\t\t\t\t\tif (! this.isPendingJoin && this.currentSession !== '')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.isPendingJoin = true;\n\t\t\t\t\t\t\t$.post(\"/api/sessions/connect/\" + this.currentSession)\n\t\t\t\t\t\t\t\t.done(function(data) { theApp.onJoin('succeed', data); })\n\t\t\t\t\t\t\t\t.fail(function() { theApp.onJoin('fail'); })\n\t\t\t\t\t\t\t\t.always(function() { theApp.onJoin('complete'); })\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'succeed':\n\t\t\t\t\tthis.setConnected(true);\n\t\t\t\t\tif (result.result === undefined)\n\t\t\t\t\t\tthis.clientContext.log(1, \"Join session succeeded but expected result status.\");\n\t\t\t\t\telse if (result.result != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (result.result == 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.isSessionFull = true;\n\t\t\t\t\t\t\tthis.isSessionReachable = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.clientContext.log(1, \"Join session succeeded but result status is \" + String(result.result));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.isSessionFull = false;\n\t\t\t\t\t\tthis.isSessionReachable = true;\n\t\t\t\t\t\tthis.clientID = result.clientID;\n\t\t\t\t\t\tthis.EditUtil.clientID = this.clientID;\n\t\t\t\t\t\tthis.clientEngine = new OT.OTClientEngine(this.clientContext, this.currentSession, this.clientID);\n\t\t\t\t\t\tif (this.UserName == '' && result.userName)\n\t\t\t\t\t\t\tthis.setUserName(result.userName);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthis.shareUserName();\n\t\t\t\t\t\tthis.fireEdits();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'fail':\n\t\t\t\t\tthis.setConnected(false);\n\t\t\t\t\tthis.isSessionReachable = false;\n\t\t\t\t\tthis.isSessionFull = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'complete':\n\t\t\t\t\tthis.isPendingJoin = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.setStatus();\n\t\t\t$(\"#scratchpad\").prop(\"readonly\", !this.isConnected || !this.isSessionReachable || this.isSessionFull);\n\t\t}\n\n\tonEdits(event: string, result?: any): void\n\t\t{\n\t\t\tswitch (event)\n\t\t\t{\n\t\t\t\tcase 'start':\n\t\t\t\t\tif (this.clientEngine.isPending())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (! this.isPendingSendEdits)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.isPendingSendEdits = true;\n\t\t\t\t\t\t\tlet edit: OT.OTCompositeResource = this.clientEngine.getPending();\n\t\t\t\t\t\t\tlet data: any = { \"clientID\": edit.clientID, \"Edit\": edit.toJSON() };\n\t\t\t\t\t\t\t$.ajax(\"/api/sessions/sendevent/\" + this.currentSession,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"method\": \"POST\",\n\t\t\t\t\t\t\t\t\t\"contentType\": \"application/json; charset=UTF-8\",\n\t\t\t\t\t\t\t\t\t\"data\": JSON.stringify(data),\n\t\t\t\t\t\t\t\t\t\"processData\": false,\n\t\t\t\t\t\t\t\t\t\"dataType\": \"json\"\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.done(function(data) { theApp.onEdits('succeed/send', data); })\n\t\t\t\t\t\t\t\t.fail(function() { theApp.onEdits('fail'); })\n\t\t\t\t\t\t\t\t.always(function() { theApp.onEdits('complete/send'); })\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (! this.isPendingReceiveEdits)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.isPendingReceiveEdits = true;\n\t\t\t\t\t\t\t$.ajax(\"/api/sessions/receiveevent/\" + this.currentSession,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"method\": \"POST\",\n\t\t\t\t\t\t\t\t\t\"data\": JSON.stringify({ \"clientID\": this.clientEngine.clientID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"NextClock\": this.clientEngine.serverClock() + 1 }),\n\t\t\t\t\t\t\t\t\t\"contentType\": \"application/json; charset=UTF-8\",\n\t\t\t\t\t\t\t\t\t\"processData\": false,\n\t\t\t\t\t\t\t\t\t\"dataType\": \"json\"\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.done(function(data) { theApp.onEdits('succeed/receive', data); })\n\t\t\t\t\t\t\t\t.fail(function() { theApp.onEdits('fail'); })\n\t\t\t\t\t\t\t\t.always(function() { theApp.onEdits('complete/receive'); })\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'succeed/send':\n\t\t\t\tcase 'succeed/receive':\n\t\t\t\t\t{\n\t\t\t\t\t\tlet nResult: number = result ? result.result : undefined;\n\t\t\t\t\t\tthis.isSessionReachable = true;\n\t\t\t\t\t\tthis.isSessionFull = false;\n\t\t\t\t\t\tthis.setConnected(true);\n\t\t\t\t\t\tif (nResult === undefined)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.clientContext.log(1, \"Send/receive succeeded but expected result status.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (nResult != OT.clockSuccess)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (nResult)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t// \"No such session\"\n\t\t\t\t\t\t\t\t\tthis.isSessionReachable = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase OT.clockInitialValue:\n\t\t\t\t\t\t\t\t\t// Ooops, need a reset\n\t\t\t\t\t\t\t\t\tthis.clientEngine.initialize();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase OT.clockSeenValue:\n\t\t\t\t\t\t\t\t\t// I already sent event - probably lost response from server but I should eventually see ack.\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase OT.clockFailureValue:\n\t\t\t\t\t\t\t\t\t// Server didn't have old clock value needed to transform my event request. Just resend with\n\t\t\t\t\t\t\t\t\t// more recent clock value.\n\t\t\t\t\t\t\t\t\tthis.clientEngine.resetPending();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t// Unknown error - reset and reinitialize\n\t\t\t\t\t\t\t\t\tthis.clientEngine.initialize();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.needRender();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet aEdits: Array<any> = result.EditList;\n\t\t\t\t\t\t\tif (aEdits && aEdits.length > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (let j: number = 0; j < aEdits.length; j++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlet a: OT.OTCompositeResource = OT.OTCompositeResource.constructFromObject(aEdits[j]);\n\t\t\t\t\t\t\t\t\tthis.clientEngine.addRemote(a);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet objVal: any = this.clientEngine.toValue();\n\t\t\t\t\t\t\t\tif (objVal['text'])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlet cursor: any = this.EditUtil.extractCursor(this.clientEngine.stateLocal);\n\t\t\t\t\t\t\t\t\tcursor = cursor ? cursor[this.clientID] : undefined;\n\t\t\t\t\t\t\t\t\tlet ss: number = cursor && cursor.selectionStart ? cursor.selectionStart : undefined;\n\t\t\t\t\t\t\t\t\tlet se: number = cursor && cursor.selectionEnd ? cursor.selectionEnd : ss;\n\t\t\t\t\t\t\t\t\tthis.setTextValue(objVal['text'], ss, se);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (objVal['WellKnownName_users'])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthis.usersValue = objVal['WellKnownName_users'];\n\t\t\t\t\t\t\t\t\t// Check if I'm in the user list, I may have been edited out for inactivity\n\t\t\t\t\t\t\t\t\tif (this.usersValue[this.clientID] == null)\n\t\t\t\t\t\t\t\t\t\tthis.shareUserName();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (objVal['chat'])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthis.chatArray = objVal['chat'];\n\t\t\t\t\t\t\t\t\tif (this.isChatOn)\n\t\t\t\t\t\t\t\t\t\tthis.nChatSeen = this.chatArray.length;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.clientContext.log(2, \"Events received: \" + String(aEdits ? aEdits.length : 0));\n\t\t\t\t\t\t\t\tthis.speed.speedUp();\n\t\t\t\t\t\t\t\tthis.needRender();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tthis.speed.slowDown();\n\t\t\t\t\t\t\tthis.setStatus();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'fail':\n\t\t\t\t\tthis.clientEngine.resetPending();\n\t\t\t\t\tthis.isSessionReachable = false;\n\t\t\t\t\tthis.setConnected(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'complete/send':\n\t\t\t\t\tthis.isPendingSendEdits = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'complete/receive':\n\t\t\t\t\tthis.isPendingReceiveEdits = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.setStatus();\n\t\t}\n\n\tfireList(): void { this.onList('start'); }\n\tfireCreate(): void { this.onCreate('start'); }\n\tfireJoin(): void { this.onJoin('start'); }\n\tfireEdits(): void { this.onEdits('start'); }\n\n\tcancelList(): void { this.onList('complete'); }\n\tcancelCreate(): void { this.onCreate('complete'); }\n\tcancelJoin(): void { this.onJoin('complete'); }\n\tcancelEdits(): void { this.onEdits('complete'); }\n\n\ttick(): void\n\t\t{\n\t\t\tif (this.isSessionFull)\n\t\t\t{\n\t\t\t\tthis.speed.slowDown();\n\t\t\t\tthis.fireJoin();\n\t\t\t}\n\t\t\telse if (this.isInSession())\n\t\t\t\tthis.fireEdits();\n\t\t\tthis.reTick();\n\t\t}\n};\n\nlet theApp: App = null;\n\n\nfunction newCB(): void\n{\n\ttheApp.newBoard();\n}\n\nfunction chatCB(): void\n{\n\ttheApp.toggleChat();\n}\n\nfunction submitChatCB(sChat: string): void\n{\n\ttheApp.submitChat(sChat);\n}\n\nfunction captureElementCB(el: any): void\n{\n\ttheApp.elTextArea = el;\n}\n\nfunction contentChangeCB(sNewVal: string, s: number, e: number): void\n{\n\tif (theApp.isInSession())\n\t{\n\t\tlet objOld: any = theApp.clientEngine.toValue();\n\t\tlet sOldVal = (objOld && objOld['text']) ? objOld['text'] : '';\n\t\tif (sOldVal != sNewVal || s != theApp.selectionStart || e != theApp.selectionEnd)\n\t\t{\n\t\t\tlet edit: OT.OTCompositeResource = theApp.EditUtil.computeEdit(sOldVal, sNewVal);\n\t\t\ttheApp.EditUtil.injectCursor(edit, s, e);\n\t\t\tif (edit.length > 0)\n\t\t\t{\n\t\t\t\ttheApp.clientEngine.addLocal(edit);\n\t\t\t\ttheApp.fireEdits();\n\t\t\t}\n\t\t}\n\t}\n\ttheApp.setTextValue(sNewVal, s, e);\n}\n\nfunction nameChangeCB(sNewVal: string): void\n{\n\ttheApp.setUserName(sNewVal);\n}\n\nfunction clickSquareCB(id: number): void\n{\n\ttheApp.clickSquare(id);\n}\n\nfunction StartupApp()\n{\n\ttheApp = new App();\n\ttheApp.Initialize();\n}\n\n\n$ ( StartupApp );\n\n\n\n// WEBPACK FOOTER //\n// ./src/client.tsx","module.exports = jQuery;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jQuery\"\n// module id = 1\n// module chunks = 0","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@terrencecrowley/ot-js\"), require(\"diff-match-patch\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@terrencecrowley/ot-js\", \"diff-match-patch\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ot-editutil\"] = factory(require(\"@terrencecrowley/ot-js\"), require(\"diff-match-patch\"));\n\telse\n\t\troot[\"ot-editutil\"] = factory(root[\"@terrencecrowley/ot-js\"], root[\"diff-match-patch\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:///webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a4469015be7ee1967645\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:/webpack/bootstrap a4469015be7ee1967645","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./otarray\"));\n__export(require(\"./otclientengine\"));\n__export(require(\"./otcomposite\"));\n__export(require(\"./otmap\"));\n__export(require(\"./otcounter\"));\n__export(require(\"./otserverengine\"));\n__export(require(\"./ottypes\"));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/all.ts\n ** module id = 0\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:///lib/all.ts","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OT = require(\"./ottypes\");\nvar TestUnitSize = 4;\nvar TestCounter = 0;\n// Array Ops\nexports.OpInsert = 1;\nexports.OpDelete = 2;\nexports.OpRetain = 3;\nexports.OpCursor = 4; // 2nd arg is 0/1 for start/end of region, 3rd arg is clientID\nexports.OpSet = 5;\nexports.OpTmpRetain = 6;\nvar OTalignEdgesType;\n(function (OTalignEdgesType) {\n    OTalignEdgesType[OTalignEdgesType[\"AlignForCompose\"] = 0] = \"AlignForCompose\";\n    OTalignEdgesType[OTalignEdgesType[\"AlignForTransform\"] = 1] = \"AlignForTransform\";\n})(OTalignEdgesType || (OTalignEdgesType = {}));\n;\n;\n// Operates on a single \"OTSingleArrayEdit\", parameterized by an object that manipulates the underlying\n// array-like value stored as the third property of the 3-element edit object.\nvar OTSingleArrayEditor = (function () {\n    function OTSingleArrayEditor(raw) {\n        this.raw = raw;\n    }\n    OTSingleArrayEditor.prototype.copy = function (a) { return [a[0], a[1], this.raw.copy(a[2])]; };\n    // Static Predicates for MoveAction\n    OTSingleArrayEditor.prototype.isDelete = function (a) { return a[0] == exports.OpDelete; };\n    OTSingleArrayEditor.prototype.isNotDelete = function (a) { return a[0] != exports.OpDelete; };\n    OTSingleArrayEditor.prototype.isCursor = function (a) { return a[0] == exports.OpCursor; };\n    OTSingleArrayEditor.prototype.isNotCursor = function (a) { return a[0] != exports.OpCursor; };\n    OTSingleArrayEditor.prototype.isTmpRetain = function (a) { return a[0] == exports.OpTmpRetain; };\n    OTSingleArrayEditor.prototype.isNotTmpRetainOrDelete = function (a) { return (a[0] != exports.OpTmpRetain && a[0] != exports.OpDelete); };\n    OTSingleArrayEditor.prototype.isTmpRetainOrDelete = function (a) { return (a[0] == exports.OpTmpRetain || a[0] == exports.OpDelete); };\n    // Other static predicates\n    OTSingleArrayEditor.prototype.isIgnore = function (a) { return a[0] < 0; };\n    OTSingleArrayEditor.prototype.isNoOp = function (a) { return a[1] === 0 && a[0] != exports.OpCursor; };\n    OTSingleArrayEditor.prototype.isEqual = function (a1, a2) { return a1[0] == a2[0] && a1[1] == a2[1] && this.raw.equal(a1[2], a2[2]); };\n    // Helpers\n    OTSingleArrayEditor.prototype.appendValue = function (a, s) { a[2] = this.raw.append(a[2], s); a[1] = a[1] + this.raw.length(s); };\n    OTSingleArrayEditor.prototype.empty = function (a) { a[0] = exports.OpCursor; a[1] = 0; a[2] = this.raw.empty(); };\n    OTSingleArrayEditor.prototype.setIgnore = function (a) { if (a[0] > 0)\n        a[0] = -a[0]; };\n    OTSingleArrayEditor.prototype.substr = function (aIn, pos, len) {\n        var sSource = aIn[2];\n        if (len > 0 && pos + len <= this.raw.length(sSource))\n            aIn[2] = this.raw.substr(sSource, pos, len);\n        aIn[1] = len;\n    };\n    OTSingleArrayEditor.prototype.substrFromRaw = function (aIn, pos, len, s) {\n        var sSource = s;\n        if (len > 0 && pos + len <= this.raw.length(sSource))\n            aIn[2] = this.raw.substr(sSource, pos, len);\n        aIn[1] = len;\n    };\n    OTSingleArrayEditor.prototype.copyWithSubstr = function (aIn, pos, len) {\n        var aOut = this.copy(aIn);\n        this.substr(aOut, pos, len);\n        return aOut;\n    };\n    return OTSingleArrayEditor;\n}());\nexports.OTSingleArrayEditor = OTSingleArrayEditor;\n;\nvar OTStringOperations = (function () {\n    function OTStringOperations() {\n    }\n    OTStringOperations.prototype.underlyingTypeName = function () { return 'string'; };\n    OTStringOperations.prototype.empty = function () { return ''; };\n    OTStringOperations.prototype.insert = function (a, pos, aInsert) {\n        var s = a;\n        var sInsert = aInsert;\n        return s.substr(0, pos) + sInsert + s.substr(pos);\n    };\n    OTStringOperations.prototype.delete = function (a, pos, len) {\n        var s = a;\n        return s.substr(0, pos) + s.substr(pos + len);\n    };\n    OTStringOperations.prototype.set = function (a, pos, aSet) {\n        var s = a;\n        var sSet = aSet;\n        return s.substr(0, pos) + sSet + s.substr(pos + sSet.length);\n    };\n    OTStringOperations.prototype.append = function (a, aAppend) {\n        var s = a;\n        var sAppend = aAppend;\n        return s + sAppend;\n    };\n    OTStringOperations.prototype.substr = function (a, pos, len) {\n        var s = a;\n        return s.substr(pos, len);\n    };\n    OTStringOperations.prototype.substrOf = function (a, pos, len, aSub) {\n        // a unused if not updated with return value contents\n        var sSub = aSub;\n        return sSub.substr(pos, len);\n    };\n    OTStringOperations.prototype.constructN = function (n) {\n        var x = ' ';\n        var s = '';\n        for (;;) {\n            if (n & 1)\n                s += x;\n            n >>= 1;\n            if (n)\n                x += x;\n            else\n                break;\n        }\n        return s;\n    };\n    OTStringOperations.prototype.equal = function (a1, a2) {\n        var s1 = a1;\n        var s2 = a2;\n        return s1 === s2;\n    };\n    OTStringOperations.prototype.copy = function (a) { return a; };\n    OTStringOperations.prototype.length = function (a) { return a.length; };\n    return OTStringOperations;\n}());\nexports.OTStringOperations = OTStringOperations;\n;\nvar OTArrayOperations = (function () {\n    function OTArrayOperations() {\n    }\n    OTArrayOperations.prototype.underlyingTypeName = function () { return 'array'; };\n    OTArrayOperations.prototype.empty = function () { return []; };\n    OTArrayOperations.prototype.insert = function (a, pos, aInsert) {\n        var arr = a;\n        var arrInsert = aInsert;\n        var arrReturn = Array(arr.length + arrInsert.length);\n        var i, j;\n        for (i = 0; i < pos; i++)\n            arrReturn[i] = arr[i];\n        for (j = 0; j < arrInsert.length; j++)\n            arrReturn[i + j] = arrInsert[j];\n        for (i = pos; i < arr.length; i++)\n            arrReturn[i + j] = arr[i];\n        return arrReturn;\n    };\n    OTArrayOperations.prototype.delete = function (a, pos, len) {\n        var arr = a;\n        arr.splice(pos, len);\n        return arr;\n    };\n    OTArrayOperations.prototype.set = function (a, pos, aSet) {\n        var arr = a;\n        var arrSet = aSet;\n        for (var i = 0; i < arrSet.length; i++)\n            arr[i + pos] = arrSet[i];\n        return arr;\n    };\n    OTArrayOperations.prototype.append = function (a, aAppend) {\n        var arr = a;\n        var arrAppend = aAppend;\n        return arr.concat(arrAppend);\n    };\n    OTArrayOperations.prototype.substr = function (a, pos, len) {\n        var arr = a;\n        return arr.slice(pos, pos + len);\n    };\n    OTArrayOperations.prototype.substrOf = function (a, pos, len, aSub) {\n        // a unused if not updated with return value contents\n        var arrSub = aSub;\n        return arrSub.slice(pos, pos + len);\n    };\n    OTArrayOperations.prototype.constructN = function (n) {\n        return new Array(n);\n    };\n    OTArrayOperations.prototype.equal = function (a1, a2) {\n        var arr1 = a1;\n        var arr2 = a2;\n        if (arr1.length != arr2.length)\n            return false;\n        for (var i = 0; i < arr1.length; i++)\n            if (arr1[i] !== arr2[i])\n                return false;\n        return true;\n    };\n    OTArrayOperations.prototype.copy = function (a) {\n        var arr = a;\n        var arrRet = new Array(arr.length);\n        for (var i = 0; i < arr.length; i++)\n            arrRet[i] = arr[i];\n        return arrRet;\n    };\n    OTArrayOperations.prototype.length = function (a) {\n        return a.length;\n    };\n    return OTArrayOperations;\n}());\nexports.OTArrayOperations = OTArrayOperations;\n;\nvar OTArrayLikeResource = (function (_super) {\n    __extends(OTArrayLikeResource, _super);\n    function OTArrayLikeResource(ed, rname) {\n        _super.call(this, rname, ed.raw.underlyingTypeName());\n        this.editor = ed;\n    }\n    OTArrayLikeResource.prototype.copy = function () {\n        return null; // Needs to be overridden\n    };\n    OTArrayLikeResource.prototype.moveEdits = function (newA, iStart, iEnd, pred) {\n        if (iEnd == undefined)\n            iEnd = this.edits.length - 1;\n        for (; iStart <= iEnd; iStart++) {\n            var a = this.edits[iStart];\n            if (!this.editor.isIgnore(a) && (pred == undefined || pred(a)))\n                newA.push(a);\n        }\n    };\n    OTArrayLikeResource.prototype.equal = function (rhs) {\n        if (this.length != rhs.length)\n            return false;\n        for (var i = 0; i < this.length; i++)\n            if (!this.editor.isEqual(this.edits[i], rhs.edits[i]))\n                return false;\n        return true;\n    };\n    // Function: OTArrayLikeResource::effectivelyEqual\n    //\n    // Description:\n    //\tA looser definition than operator==. Returns true if two actions would result in the\n    //\tsame final string. This ignores no-ops like OpCursor and allows different orderings of\n    //\tinserts and deletes at the same location.\n    //\n    //  Played around with different algorithms, but the simplest is probably just to apply\n    //\tthe two actions and see if I get the same final string. Came up with an interesting\n    //\talgorithm of walking through comparing hashes, but that was not robust to operations\n    //\tbeing split into fragments and interposed with alternate ops (OpCursor or interleaving of Ins/Del)\n    //\tthat still leave the string the same. If unhappy with this approach (which scales with size\n    //\tof string to edit rather than complexity of the edit), the other approach would be to canonicalize\n    //\tthe edit operations (including removing cursor operations and normalizing order of deletes).\n    //\t(Added that version of the algorithm under #ifdef). Could also dynamically choose approach based\n    //\ton relative size of arrays.\n    //\n    OTArrayLikeResource.prototype.effectivelyEqual = function (rhs) {\n        // Exactly equal is always effectively equal\n        if (this.equal(rhs))\n            return true;\n        if (this.originalLength() != rhs.originalLength())\n            return false;\n        // Preferred algorithm\n        var s = this.editor.raw.constructN(this.originalLength());\n        var sL = this.apply(s);\n        var sR = rhs.apply(s);\n        return sL === sR;\n        // Alternate algorithm (see above)\n        //let aL: OTArrayLikeResource = this.copy();\n        //let aR: OTArrayLikeResource = rhs.copy();\n        //aL.fullyCoalesce();\n        //aR.fullyCoalesce();\n        //return aL.equal(aR);\n    };\n    OTArrayLikeResource.prototype.basesConsistent = function (rhs) {\n        if (this.originalLength() != rhs.originalLength()) {\n            console.log(\"Logic Failure: transform: Bases Inconsistent.\");\n            throw (\"Logic Failure: transform: Bases Inconsistent.\");\n        }\n    };\n    OTArrayLikeResource.prototype.originalLength = function () {\n        var len = 0;\n        for (var i = 0; i < this.length; i++) {\n            var a = this.edits[i];\n            if (a[0] == exports.OpRetain || a[0] == exports.OpDelete || a[0] == exports.OpSet)\n                len += a[1];\n        }\n        return len;\n    };\n    OTArrayLikeResource.prototype.finalLength = function () {\n        var len = 0;\n        for (var i = 0; i < this.length; i++) {\n            var a = this.edits[i];\n            if (a[0] == exports.OpRetain || a[0] == exports.OpInsert || a[0] == exports.OpSet)\n                len += a[1];\n        }\n        return len;\n    };\n    OTArrayLikeResource.prototype.apply = function (aValue) {\n        if (aValue == null)\n            aValue = this.editor.raw.empty();\n        var pos = 0;\n        for (var i = 0; i < this.length; i++) {\n            var a = this.edits[i];\n            switch (a[0]) {\n                case exports.OpRetain:\n                    pos += a[1];\n                    break;\n                case exports.OpCursor:\n                    break;\n                case exports.OpDelete:\n                    aValue = this.editor.raw.delete(aValue, pos, a[1]);\n                    break;\n                case exports.OpInsert:\n                    aValue = this.editor.raw.insert(aValue, pos, a[2]);\n                    pos += a[1];\n                    break;\n                case exports.OpSet:\n                    aValue = this.editor.raw.set(aValue, pos, a[2]);\n                    pos += a[1];\n                    break;\n            }\n        }\n        return aValue;\n    };\n    OTArrayLikeResource.prototype.coalesce = function (bDeleteCursor) {\n        if (bDeleteCursor === void 0) { bDeleteCursor = false; }\n        if (this.length == 0)\n            return;\n        // coalesce adjoining actions and delete no-ops\n        var newA = [];\n        var aLast;\n        for (var i = 0; i < this.length; i++) {\n            var aNext = this.edits[i];\n            if (this.editor.isNoOp(aNext) || (bDeleteCursor && aNext[0] == exports.OpCursor))\n                continue;\n            if (newA.length > 0 && aNext[0] == aLast[0]) {\n                if (aNext[0] == exports.OpInsert || aNext[0] == exports.OpSet)\n                    this.editor.appendValue(aLast, aNext[2]);\n                else\n                    aLast[1] += aNext[1];\n            }\n            else {\n                newA.push(aNext);\n                aLast = aNext;\n            }\n        }\n        this.edits = newA;\n    };\n    // Function: fullyCoalesce\n    //\n    // Description:\n    //\tHeavier duty version of coalesce that fully normalizes so that two actions that result in same\n    //\tfinal edit are exactly the same. This normalizes order of insert/deletes and deletes OpCursor,\n    //\tand then does coalesce.\n    //\n    OTArrayLikeResource.prototype.fullyCoalesce = function () {\n        // TODO\n        this.coalesce(true);\n    };\n    // Function: Invert\n    //\n    // Description:\n    //\tGiven an action, convert it to its inverse (action + inverse) = identity (retain(n)).\n    //\n    //\tNote that in order to compute the inverse, you need the input state (e.g. because in order to invert\n    //\tOpDelete, you need to know the deleted characters.\n    //\n    OTArrayLikeResource.prototype.invert = function (sInput) {\n        var pos = 0; // Tracks position in input string.\n        for (var i = 0; i < this.length; i++) {\n            var a = this.edits[i];\n            switch (a[0]) {\n                case exports.OpCursor:\n                    break;\n                case exports.OpRetain:\n                    pos += a[1];\n                    break;\n                case exports.OpInsert:\n                    a[2] = '';\n                    a[0] = exports.OpDelete;\n                    break;\n                case exports.OpDelete:\n                    a[2] = this.editor.copyWithSubstr(sInput, pos, a[1]);\n                    a[0] = exports.OpInsert;\n                    pos += a[1];\n                    break;\n                case exports.OpSet:\n                    a[2] = this.editor.copyWithSubstr(sInput, pos, a[1]);\n                    pos += a[1];\n                    break;\n            }\n        }\n    };\n    // Function: alignEdges\n    //\n    // Description:\n    //\tSlice up this action sequence so its edges align with the action sequence I am going to\n    //\tprocess it with. The processing (compose or transform) determines which actions Slice\n    //\ttakes into account when moving the parallel counters forward. When processing for\n    //\tcompose, deletes in rhs can be ignored. When processing for transform, inserts in both\n    //\tlhs and rhs can be ignored.\n    //\t\n    OTArrayLikeResource.prototype.alignEdges = function (rhs, st) {\n        var posR = 0;\n        var posL = 0;\n        var iL = 0;\n        var newA = [];\n        var aAfter = undefined;\n        var aL = undefined;\n        for (var iR = 0; iR < rhs.length; iR++) {\n            var aR = rhs.edits[iR];\n            switch (aR[0]) {\n                case exports.OpCursor:\n                    break;\n                case exports.OpInsert:\n                    break;\n                case exports.OpDelete:\n                    posR += aR[1];\n                    break;\n                case exports.OpSet:\n                    posR += aR[1];\n                    break;\n                case exports.OpRetain:\n                    posR += aR[1];\n                    break;\n            }\n            // Advance iL/posL to equal to posR\n            while (posL < posR && (aAfter != undefined || iL < this.length)) {\n                if (aAfter == undefined) {\n                    aL = this.edits[iL];\n                    newA.push(aL);\n                    iL++;\n                }\n                else {\n                    aL = aAfter;\n                }\n                switch (aL[0]) {\n                    case exports.OpCursor:\n                        break;\n                    case exports.OpInsert:\n                        if (st == OTalignEdgesType.AlignForCompose)\n                            posL += aL[1];\n                        break;\n                    case exports.OpDelete:\n                        if (st == OTalignEdgesType.AlignForTransform)\n                            posL += aL[1];\n                        break;\n                    case exports.OpSet:\n                        posL += aL[1];\n                        break;\n                    case exports.OpRetain:\n                        posL += aL[1];\n                        break;\n                }\n                // Split this one if it spans boundary\n                if (posL > posR) {\n                    var nRight = posL - posR;\n                    var nLeft = aL[1] - nRight;\n                    aAfter = this.editor.copyWithSubstr(aL, nLeft, nRight);\n                    this.editor.substr(aL, 0, nLeft);\n                    newA.push(aAfter);\n                    posL = posR;\n                }\n                else\n                    aAfter = undefined;\n            }\n        }\n        // Append any we missed\n        this.moveEdits(newA, iL);\n        this.edits = newA;\n    };\n    OTArrayLikeResource.prototype.getCursorCache = function () {\n        var cursorCache = {};\n        for (var i = 0; i < this.length; i++) {\n            var a = this.edits[i];\n            if (a[0] == exports.OpCursor && a[2] != null)\n                cursorCache[a[2]] = '';\n        }\n        return cursorCache;\n    };\n    // Function: compose\n    //\n    // Description:\n    //\tcompose the current action with the action passed in. This alters the current action.\n    //\n    //\tBasic structure is to walk through the RHS list of actions, processing each one in turn.\n    //\tThat then drives the walk through the left hand side and the necessary edits. I use\n    //\t\"posR\" and \"posL\" to work through equivalent positions in the two strings being edited.\n    //\tDeletions in the LHS don't effect posL because they don't show up in the input string to RHS.\n    //\tSimilarly, insertions in the RHS don't effect posR since they have no equivalent string location\n    //\tin the LHS.\t(Note transform follows similar structure but different logic for how posR and posL\n    //\ttrack each other since in that case they are effectively referencing the same input string.)\n    //\n    OTArrayLikeResource.prototype.compose = function (rhs) {\n        var cursorCache = rhs.getCursorCache();\n        if (this.length == 0) {\n            this.edits = rhs.edits.map(this.editor.copy, this.editor);\n            return;\n        }\n        else if (rhs.edits.length == 0)\n            return;\n        if (this.finalLength() != rhs.originalLength()) {\n            console.log(\"Logic Failure: compose: Bases Inconsistent.\");\n            throw (\"Logic Failure: compose: Bases Inconsistent.\");\n        }\n        // Break overlapping segments before start to simplify logic below.\n        this.alignEdges(rhs, OTalignEdgesType.AlignForCompose);\n        // Iterate with parallel position markers in two arrays\n        var posR = 0;\n        var posL = 0;\n        var iL = 0;\n        var bDone;\n        var newA = [];\n        for (var iR = 0; iR < rhs.length; iR++) {\n            var aR = rhs.edits[iR];\n            switch (aR[0]) {\n                case exports.OpRetain:\n                    posR += aR[1];\n                    break;\n                case exports.OpSet:\n                case exports.OpDelete:\n                case exports.OpInsert:\n                case exports.OpCursor:\n                    // Advance to cursor location\n                    bDone = false;\n                    while (!bDone && iL < this.length) {\n                        var aL = this.edits[iL];\n                        switch (aL[0]) {\n                            case exports.OpCursor:\n                                // Only copy old cursor locations if they aren't empty and aren't duplicated in this rhs.\n                                if (aL[2] != '' && cursorCache[aL[2]] === undefined)\n                                    newA.push(aL);\n                                iL++;\n                                break;\n                            case exports.OpSet:\n                            case exports.OpRetain:\n                            case exports.OpInsert:\n                                if (posL == posR)\n                                    bDone = true;\n                                else {\n                                    posL += aL[1];\n                                    newA.push(aL);\n                                    iL++;\n                                }\n                                break;\n                            case exports.OpDelete:\n                                newA.push(aL);\n                                iL++; // Move past since deletes are not referenced by RHS\n                                break;\n                        }\n                    }\n                    if (aR[0] == exports.OpDelete) {\n                        // Remove sequence of cursor, insert, retains, sets, replaced by delete.\n                        // Note that insert/delete cancel each other out, so there is a bit of complexity there.\n                        var nChange = aR[1];\n                        var nRemain = aR[1];\n                        for (; nChange > 0 && iL < this.length; iL++) {\n                            var aL = this.edits[iL];\n                            switch (aL[0]) {\n                                case exports.OpCursor:\n                                    // Only copy old cursor locations if they aren't empty and aren't duplicated in this rhs.\n                                    if (aL[2] != '' && cursorCache[aL[2]] === undefined)\n                                        newA.push(aL);\n                                    break;\n                                case exports.OpDelete:\n                                    newA.push(aL);\n                                    break;\n                                case exports.OpSet:\n                                case exports.OpRetain:\n                                case exports.OpInsert:\n                                    nRemain -= aL[0] == exports.OpInsert ? aL[1] : 0;\n                                    nChange -= aL[1];\n                                    // Don't copy into new array\n                                    break;\n                            }\n                        }\n                        // Now add in the delete\n                        if (nRemain > 0)\n                            newA.push([exports.OpDelete, nRemain, '']);\n                    }\n                    else if (aR[0] == exports.OpSet) {\n                        // Process sequence of cursor, insert, retains, sets\n                        var nChange = aR[1];\n                        for (; nChange > 0 && iL < this.length; iL++) {\n                            var aL = this.edits[iL];\n                            var opL = exports.OpInsert;\n                            switch (aL[0]) {\n                                case exports.OpCursor:\n                                    // Only copy old cursor locations if they aren't empty and aren't duplicated in this rhs.\n                                    if (aL[2] != '' && cursorCache[aL[2]] === undefined)\n                                        newA.push(aL);\n                                    break;\n                                case exports.OpDelete:\n                                    newA.push(aL);\n                                    break;\n                                case exports.OpSet:\n                                case exports.OpRetain:\n                                    opL = exports.OpSet;\n                                // fallthrough\n                                case exports.OpInsert:\n                                    // A Set composed with Insert becomes Insert of Set content\n                                    this.editor.substrFromRaw(aL, aR[1] - nChange, aL[1], aR[2]);\n                                    aL[0] = opL;\n                                    nChange -= aL[1];\n                                    newA.push(aL);\n                                    break;\n                            }\n                        }\n                    }\n                    else {\n                        // Add in the RHS operation at proper location\n                        newA.push(this.editor.copy(aR));\n                    }\n                    break;\n            }\n        }\n        // copy any remaining actions, excluding cursors duplicated in rhs\n        this.moveEdits(newA, iL, this.length - 1, function (e) { return (e[0] != exports.OpCursor) || (e[2] != '' && cursorCache[e[2]] === undefined); });\n        this.edits = newA;\n        this.coalesce();\n    };\n    OTArrayLikeResource.prototype.performTransformReorder = function (bForceRetainBeforeInsert, newA, iBegin, iEnd) {\n        if (iBegin < 0 || iBegin > iEnd)\n            return;\n        if (bForceRetainBeforeInsert) {\n            this.moveEdits(newA, iBegin, iEnd, this.editor.isTmpRetainOrDelete);\n            this.moveEdits(newA, iBegin, iEnd, this.editor.isNotTmpRetainOrDelete); // Is Insert or Cursor\n        }\n        else {\n            this.moveEdits(newA, iBegin, iEnd, this.editor.isNotTmpRetainOrDelete); // Is Insert or Cursor\n            this.moveEdits(newA, iBegin, iEnd, this.editor.isTmpRetainOrDelete);\n        }\n    };\n    // Function: normalizeNewRetainsAfterTransform\n    //\n    // Description:\n    //\tHelper function for transform() that does a post-processing pass to ensure that all\n    //\tRetains are properly ordered with respect to Inserts that occur at the same location\n    //\t(either before or after, depending on whether we are transforming based on server or client side).\n    //\tThis ensures that the transform process is not sensitive to precise ordering of Inserts and\n    //\tRetains (since that ordering doesn't actually change the semantics of the edit performed and\n    //\ttherefore should not result in a difference in processing here). And yes, it's a subtle issue\n    //\tthat may not actually occur in real edits produced by some particular editor but does arise when\n    //\ttesting against randomly generated edit streams.\n    //\n    //\tA side consequence is also normalizing the ordering of inserts and deletes which also doesn't\n    //\tchange the semantics of the edit but ensures we properly detect conflicting insertions.\n    //\n    //\tThe way to think of this algorithm is that Set's and Retains (pre-existing, not new TmpRetains) form\n    //\thard boundaries in the ordering. The series of Cursor/TmpRetain/Insert/Deletes between Sets and Retains\n    //\tare re-ordered by this algorithm. TmpRetain's get pushed to the front or the back depending on the bForce\n    //\tflag passed in (which reflects which operation had precedence).\n    //\n    OTArrayLikeResource.prototype.normalizeNewRetainsAfterTransform = function (bForceRetainBeforeInsert) {\n        if (this.length == 0)\n            return;\n        var i = 0;\n        var newA = [];\n        var iLastEdge = 0;\n        // Normalize ordering for newly insert retains so they are properly ordered\n        // with respect to inserts occurring at the same location.\n        for (i = 0; i < this.length; i++) {\n            var a = this.edits[i];\n            if (a[0] == exports.OpSet || a[0] == exports.OpRetain) {\n                this.performTransformReorder(bForceRetainBeforeInsert, newA, iLastEdge, i - 1);\n                newA.push(a);\n                iLastEdge = i + 1;\n            }\n        }\n        this.performTransformReorder(bForceRetainBeforeInsert, newA, iLastEdge, this.length - 1);\n        // One last time to switch TmpRetain to Retain\n        for (i = 0; i < newA.length; i++)\n            if ((newA[i])[0] == exports.OpTmpRetain)\n                (newA[i])[0] = exports.OpRetain;\n        this.edits = newA;\n    };\n    OTArrayLikeResource.prototype.transform = function (prior, bPriorIsService) {\n        if (this.length == 0 || prior.length == 0)\n            return;\n        // Validate\n        this.basesConsistent(prior);\n        // Break overlapping segments before start to simplify logic below.\n        this.alignEdges(prior, OTalignEdgesType.AlignForTransform);\n        var posR = 0; // These walk in parallel across the consistent base strings (only retains, sets and deletes count)\n        var posL = 0;\n        var iL = 0;\n        var bDone;\n        var newA = [];\n        for (var iR = 0; iR < prior.length; iR++) {\n            var aR = prior.edits[iR];\n            switch (aR[0]) {\n                case exports.OpCursor:\n                    // No-op\n                    break;\n                case exports.OpInsert:\n                    {\n                        // Converts to a retain.\n                        // Need to find spot to insert retain. After loop, iL will contain location\n                        for (; iL < this.length; iL++) {\n                            if (posR == posL)\n                                break;\n                            var aL = this.edits[iL];\n                            if (this.editor.isIgnore(aL))\n                                continue;\n                            if (aL[0] != exports.OpCursor && aL[0] != exports.OpInsert)\n                                posL += aL[1];\n                            newA.push(aL);\n                        }\n                        var nRetain = aR[1];\n                        newA.push([exports.OpTmpRetain, nRetain, '']);\n                        posR += nRetain;\n                        posL += nRetain;\n                    }\n                    break;\n                case exports.OpSet:\n                    // Somewhat unintuitively, if prior is *not* service, then it will actually get applied *after*\n                    // the service instance of OpSet and so should take precedence. Therefore if prior is not service,\n                    // we need to go through and convert \"OpSets\" that overlap to be this content. If prior is service,\n                    // we can just treat them as \"retains\" since they have no effect on our operations.\n                    if (bPriorIsService)\n                        posR += aR[1];\n                    else {\n                        var nRemaining = aR[1];\n                        while (nRemaining > 0 && iL < this.length) {\n                            var aL = this.edits[iL];\n                            if (this.editor.isIgnore(aL)) {\n                                iL++;\n                                continue;\n                            }\n                            var valL = aL[1];\n                            if (aL[0] == exports.OpCursor || aL[0] == exports.OpInsert) {\n                                iL++;\n                                newA.push(aL);\n                            }\n                            else {\n                                if (posR >= posL + valL) {\n                                    // Not there yet\n                                    posL += valL;\n                                    iL++;\n                                    newA.push(aL);\n                                }\n                                else {\n                                    if (aL[0] == exports.OpDelete || aL[0] == exports.OpRetain) {\n                                        if (valL <= nRemaining) {\n                                            posR += valL;\n                                            posL += valL;\n                                            nRemaining -= valL;\n                                            iL++;\n                                            newA.push(aL);\n                                        }\n                                        else {\n                                            // Not subsumed, but means that I didn't encounter an OpSet\n                                            posR += nRemaining;\n                                            nRemaining = 0;\n                                        }\n                                    }\n                                    else {\n                                        if (aL[1] <= nRemaining) {\n                                            posR += valL;\n                                            posL += valL;\n                                            this.editor.substrFromRaw(aL, aR[1] - nRemaining, valL, aR[2]);\n                                            nRemaining -= valL;\n                                            iL++;\n                                            newA.push(aL);\n                                        }\n                                        else {\n                                            // don't advance posL or iL because we will re-process the left over\n                                            // part for the next action. Simply edit the data in place.\n                                            // Set [0, nRemaining] of aL.Data to [aR[1]-nRemaining, nRemaining]\n                                            //aL.Data.delete(0, nRemaining);\n                                            //aL.Data.InsertValue(0, aR.Data, aR[1]-nRemaining, nRemaining);\n                                            aL[2] = aR[2].substr(aR[1] - nRemaining) + aL[2].substr(nRemaining);\n                                            posR += nRemaining;\n                                            nRemaining = 0;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    break;\n                case exports.OpDelete:\n                    {\n                        var nRemaining = aR[1];\n                        var nDelay = 0;\n                        var iDelay = void 0;\n                        // Retains, sets and deletes are subsumed by prior deletes\n                        for (; nRemaining > 0 && iL < this.length; iL++) {\n                            var aL = this.edits[iL];\n                            if (this.editor.isIgnore(aL)) {\n                                if (nDelay > 0)\n                                    nDelay++;\n                                continue;\n                            }\n                            if (aL[0] == exports.OpCursor || aL[0] == exports.OpInsert) {\n                                if (nDelay == 0)\n                                    iDelay = iL;\n                                nDelay++;\n                            }\n                            else {\n                                if (posR >= posL + aL[1]) {\n                                    // Go ahead and push any delayed actions\n                                    for (var j = iDelay; nDelay > 0; nDelay--, j++) {\n                                        var aD = this.edits[j];\n                                        if (!this.editor.isIgnore(aD))\n                                            newA.push(aD);\n                                    }\n                                    // Prior to the deleted content\n                                    posL += aL[1];\n                                    newA.push(aL);\n                                }\n                                else {\n                                    // Retain/set/delete is fully subsumed.\n                                    posR += aL[1];\n                                    posL += aL[1];\n                                    nRemaining -= aL[1];\n                                    this.editor.setIgnore(aL);\n                                    if (nDelay > 0)\n                                        nDelay++;\n                                }\n                            }\n                        }\n                        // We want to reprocess any trailing insert/cursors so we recognize conflicting inserts even when\n                        // deletes intervene.\n                        if (nDelay > 0)\n                            iL = iDelay;\n                    }\n                    break;\n                case exports.OpRetain:\n                    // Just advance cursor\n                    posR += aR[1];\n                    break;\n            }\n        }\n        this.moveEdits(newA, iL);\n        this.edits = newA;\n        this.normalizeNewRetainsAfterTransform(bPriorIsService);\n        this.coalesce();\n    };\n    //\n    // Function: generateRandom\n    //\n    // Description:\n    //\tGenerate action containing a sequence of retain, insert, delete, cursor with the initial\n    //\tstate of the string being nInitial. Make sure I always generate at least one insert or delete.\n    //\tAlways operate in units of 4 (.123).\n    //\n    OTArrayLikeResource.prototype.generateRandom = function (nInitial, clientID) {\n        // Ensure clean start\n        this.empty();\n        // Setup randomizer\n        var nOps = 0;\n        var nLen;\n        var nBound;\n        var s;\n        while (nInitial > 0 || nOps == 0) {\n            var op = randomWithinRange(0, 4);\n            nBound = nInitial / TestUnitSize;\n            if (nInitial == 0 && (op == exports.OpDelete || op == exports.OpRetain || op == exports.OpSet))\n                continue;\n            switch (op) {\n                case exports.OpInsert:\n                    nOps++;\n                    nLen = randomWithinRange(1, 5);\n                    s = this.editor.raw.empty();\n                    for (var i = 0; i < nLen; i++)\n                        s = this.editor.raw.append(s, counterValue(this.editor.raw, TestCounter++));\n                    nLen *= TestUnitSize;\n                    this.edits.push([exports.OpInsert, nLen, s]);\n                    break;\n                case exports.OpDelete:\n                    nOps++;\n                    nLen = randomWithinRange(1, nBound > 3 ? nBound / 3 : nBound);\n                    nLen *= TestUnitSize;\n                    nInitial -= nLen;\n                    this.edits.push([exports.OpDelete, nLen, this.editor.raw.empty()]);\n                    break;\n                case exports.OpCursor:\n                    this.edits.push([exports.OpCursor, 0, clientID]);\n                    break;\n                case exports.OpRetain:\n                    nLen = randomWithinRange(1, nBound);\n                    nLen *= TestUnitSize;\n                    nInitial -= nLen;\n                    this.edits.push([exports.OpRetain, nLen, this.editor.raw.empty()]);\n                    break;\n                case exports.OpSet:\n                    nLen = 1;\n                    s = this.editor.raw.empty();\n                    for (var i = 0; i < nLen; i++)\n                        this.editor.raw.append(s, counterValue(this.editor.raw, TestCounter++));\n                    nLen *= TestUnitSize;\n                    nInitial -= nLen;\n                    this.edits.push([exports.OpSet, nLen, s]);\n                    break;\n            }\n        }\n        // Most importantly ensures canonical ordering of inserts and deletes.\n        this.coalesce();\n    };\n    return OTArrayLikeResource;\n}(OT.OTResourceBase));\nexports.OTArrayLikeResource = OTArrayLikeResource;\nvar OTStringResource = (function (_super) {\n    __extends(OTStringResource, _super);\n    function OTStringResource(rname) {\n        _super.call(this, OTStringResource._editor, rname);\n    }\n    OTStringResource.factory = function (rname) { return new OTStringResource(rname); };\n    OTStringResource.prototype.copy = function () {\n        var copy = new OTStringResource(this.resourceName);\n        copy.edits = this.edits.map(copy.editor.copy, copy.editor);\n        return copy;\n    };\n    OTStringResource._editor = new OTSingleArrayEditor(new OTStringOperations());\n    return OTStringResource;\n}(OTArrayLikeResource));\nexports.OTStringResource = OTStringResource;\nvar OTArrayResource = (function (_super) {\n    __extends(OTArrayResource, _super);\n    function OTArrayResource(rname) {\n        _super.call(this, OTArrayResource._editor, rname);\n    }\n    OTArrayResource.factory = function (rname) { return new OTArrayResource(rname); };\n    OTArrayResource.prototype.copy = function () {\n        var copy = new OTArrayResource(this.resourceName);\n        copy.edits = this.edits.map(copy.editor.copy, copy.editor);\n        return copy;\n    };\n    OTArrayResource._editor = new OTSingleArrayEditor(new OTArrayOperations());\n    return OTArrayResource;\n}(OTArrayLikeResource));\nexports.OTArrayResource = OTArrayResource;\nfunction randomWithinRange(nMin, nMax) {\n    return nMin + Math.floor(Math.random() * (nMax - nMin + 1));\n}\nfunction counterValue(ops, c) {\n    switch (ops.underlyingTypeName()) {\n        case 'string':\n            {\n                var a = new Array(TestUnitSize);\n                a[0] = '.';\n                for (var j = 1; j < TestUnitSize; j++, c = Math.floor(c / 10))\n                    a[TestUnitSize - j] = \"\" + (c % 10);\n                return a.join('');\n            }\n        case 'array':\n            {\n                var a = new Array(TestUnitSize);\n                for (var i = 0; i < TestUnitSize; i++, c += 0.1)\n                    a[i] = c;\n                return a;\n            }\n        default:\n            throw \"counterValue: Unexpected underlying array-like type.\";\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/otarray.ts\n ** module id = 1\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:///lib/otarray.ts","\"use strict\";\n// Useful base class\nvar OTResourceBase = (function () {\n    function OTResourceBase(rname, utype) {\n        this.resourceName = rname;\n        this.underlyingType = utype;\n        this.edits = [];\n    }\n    Object.defineProperty(OTResourceBase.prototype, \"length\", {\n        get: function () {\n            return this.edits.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Set an existing instance of the operation to be empty\n    OTResourceBase.prototype.empty = function () {\n        this.edits = [];\n    };\n    // Test\n    OTResourceBase.prototype.isEmpty = function () {\n        return this.edits.length == 0;\n    };\n    // Copy an instance\n    OTResourceBase.prototype.copy = function () {\n        throw \"OTResourceBase.copy must be overridden in subclass\";\n    };\n    // Test whether two operations are effectively equivalent\n    OTResourceBase.prototype.effectivelyEqual = function (rhs) {\n        throw \"OTResourceBase.effectivelyEqual must be overridden in subclass\";\n    };\n    // Core OT algorithm for this type\n    OTResourceBase.prototype.transform = function (rhs, bPriorIsService) {\n        throw \"OTResourceBase.transform must be overridden in subclass\";\n    };\n    // compose two edit actions\n    OTResourceBase.prototype.compose = function (rhs) {\n        throw \"OTResourceBase.compose must be overridden in subclass\";\n    };\n    // apply this edit to an existing value, returning new value (if underlying type is mutable, may modify input)\n    OTResourceBase.prototype.apply = function (startValue) {\n        throw \"OTResourceBase.apply must be overridden in subclass\";\n    };\n    OTResourceBase.prototype.minimize = function () {\n        // Default implementation does nothing.\n    };\n    return OTResourceBase;\n}());\nexports.OTResourceBase = OTResourceBase;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/ottypes.ts\n ** module id = 2\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:///lib/ottypes.ts","\"use strict\";\nvar OTC = require(\"./otcomposite\");\nvar OTClientEngine = (function () {\n    // Constructor\n    function OTClientEngine(ctx, rid, cid) {\n        this.context = ctx;\n        this.resourceID = rid;\n        this.clientID = cid;\n        this.initialize();\n    }\n    OTClientEngine.prototype.initialize = function () {\n        this.clientSequenceNo = 0;\n        this.isNeedAck = false;\n        this.isNeedResend = false;\n        this.actionAllClient = new OTC.OTCompositeResource(this.resourceID, this.clientID);\n        this.actionAllPendingClient = new OTC.OTCompositeResource(this.resourceID, this.clientID);\n        this.actionSentClient = new OTC.OTCompositeResource(this.resourceID, this.clientID);\n        this.actionSentClientOriginal = new OTC.OTCompositeResource(this.resourceID, this.clientID);\n        this.actionServerInterposedSentClient = new OTC.OTCompositeResource(this.resourceID, this.clientID);\n        this.stateServer = new OTC.OTCompositeResource(this.resourceID, this.clientID);\n        this.stateLocal = new OTC.OTCompositeResource(this.resourceID, this.clientID);\n    };\n    // Members\n    OTClientEngine.prototype.serverClock = function () {\n        return this.stateServer.clock;\n    };\n    OTClientEngine.prototype.toValue = function () {\n        return this.stateLocal.toValue();\n    };\n    OTClientEngine.prototype.isPending = function () {\n        return !this.actionAllPendingClient.isEmpty();\n    };\n    OTClientEngine.prototype.getPending = function () {\n        if (this.actionAllPendingClient.isEmpty())\n            return null;\n        else {\n            // If \"isNeedResend\" I need to send the exact same event (instead of aggregating all pending)\n            // because the server might have actually received and processed the event and I just didn't\n            // receive acknowledgement. If I merge that event into others I'll lose ability to distinguish\n            // that. Eventually when I re-establish communication with server I will get that event response\n            // and can then move on.\n            if (!this.isNeedResend) {\n                this.actionSentClient = this.actionAllPendingClient.copy();\n                this.actionSentClient.clientSequenceNo = this.clientSequenceNo++;\n                this.actionAllPendingClient.empty();\n            }\n            this.actionSentClient.clock = this.stateServer.clock;\n            this.actionSentClientOriginal = this.actionSentClient.copy();\n            this.actionServerInterposedSentClient.empty();\n            this.isNeedAck = true;\n            this.isNeedResend = false;\n            return this.actionSentClient.copy();\n        }\n    };\n    // When I fail to send, I need to reset to resend the event again\n    OTClientEngine.prototype.resetPending = function () {\n        if (this.isNeedAck) {\n            this.isNeedAck = false;\n            this.isNeedResend = true;\n        }\n    };\n    // When I don't accurately have server state - will then refresh from server\n    OTClientEngine.prototype.failbackToInitialState = function () {\n        this.context.log(2, \"clientID: \" + this.clientID + \": FailbackToInitialState\");\n        this.initialize();\n    };\n    // When I have server state but my state got mixed up\n    OTClientEngine.prototype.failbackToServerState = function () {\n        this.context.log(2, \"clientID: \" + this.clientID + \": FailbackToServerState\");\n        this.stateLocal = this.stateServer.copy();\n        this.isNeedAck = false;\n        this.actionSentClient.empty();\n        this.actionSentClientOriginal.empty();\n        this.actionServerInterposedSentClient.empty();\n        this.actionAllPendingClient.empty();\n        this.actionAllClient.empty();\n    };\n    //\n    // Function: OTClientEngine.addRemote\n    //\n    // Description:\n    //\tThis function is really where the action is in managing the dynamic logic of applying OT. This is run\n    //\ton each end point and handles the events received from the server. This includes server acknowledgements\n    //\t(both success and failure) of locally generated events as well as all the events generated from other\n    //\tclients.\n    //\n    //\tThe key things that happen here are:\n    //\t\t1. Track server state.\n    //\t\t2. Respond to server acknowledgement of locally generated events. This also includes validation\n    //\t\t\t(with failback code) in case where server transformed my event in a way that was inconsistent\n    //\t\t\twith what I expected (due to insert collision that arose due to multiple independent events).\n    //\t\t3. Transform the incoming event (by local events) so it can be applied to local state.\n    //\t\t4. Transform pending local events so they can be dispatched to the service once the service\n    //\t\t\tis ready for another event.\n    //\n    OTClientEngine.prototype.addRemote = function (orig) {\n        // Reset if server forces restart\n        if (orig.clock == OTC.clockInitialValue) {\n            this.failbackToInitialState();\n            return;\n        }\n        // Reset if server restarted and we don't sync up\n        if (orig.clock < 0) {\n            // If server didn't lose anything I can just keep going...\n            if (this.stateServer.clock + 1 == -orig.clock)\n                orig.clock = -orig.clock;\n            else {\n                this.failbackToInitialState();\n                return;\n            }\n        }\n        // Ignore if I've seen this event already\n        if (orig.clock <= this.serverClock()) {\n            this.context.log(10, \"clientID: \" + this.clientID + \" addRemote: Event clientID: \" + orig.clientID + \" Event clock: \" + orig.clock + \": IGNORE\");\n            return;\n        }\n        this.context.log(10, \"clientID: \" + this.clientID + \" addRemote: Event clientID: \" + orig.clientID + \" Event clock: \" + orig.clock);\n        var bMine = orig.clientID == this.clientID;\n        var bResend = bMine && orig.clock == OTC.clockFailureValue;\n        var a = orig.copy();\n        if (bResend) {\n            // Service failed my request. Retry with currently outstanding content.\n            this.resetPending();\n            return;\n        }\n        try {\n            // Track server state and clock\n            this.stateServer.compose(a);\n            if (bMine) {\n                // Validate that I didn't run into unresolvable conflict\n                if (!this.actionServerInterposedSentClient.isEmpty()) {\n                    this.actionSentClientOriginal.transform(this.actionServerInterposedSentClient, true);\n                    if (!this.actionSentClient.effectivelyEqual(this.actionSentClientOriginal)) {\n                        this.context.log(10, \"clientID: \" + this.clientID + \" addRemote: Normal Failback\");\n                        this.failbackToServerState();\n                    }\n                }\n                // I don't need to apply to local state since it has already been applied - this is just an ack.\n                this.isNeedAck = false;\n                this.actionSentClient.empty();\n                this.actionSentClientOriginal.empty();\n                this.actionServerInterposedSentClient.empty();\n                this.actionAllClient = this.actionAllPendingClient.copy();\n            }\n            else {\n                // Transform server action to apply locally by transforming by all pending client actions\n                a.transform(this.actionAllClient, false);\n                // And then compose with local state\n                this.stateLocal.compose(a);\n                // Transform pending client by server action so it is rooted off the server state.\n                // This ensures that I can convert the next server action I receive.\n                this.actionAllClient.transform(orig, true);\n                // Transform server action to be after previously sent client action and then\n                // transform the unsent actions so they are ready to be sent.\n                var aServerTransformed = orig.copy();\n                aServerTransformed.transform(this.actionSentClient, false);\n                this.actionAllPendingClient.transform(aServerTransformed, true);\n                // And then transform the sent client action so ready to be used for transforming next server event\n                this.actionSentClient.transform(orig, true);\n                // Track server operations interposed between a sent action\n                if (this.isNeedAck)\n                    this.actionServerInterposedSentClient.compose(orig);\n            }\n        }\n        catch (err) {\n            this.failbackToServerState();\n        }\n    };\n    //\n    // Function: addLocal\n    //\n    // Description:\n    //\tThis is the logic for adding an action to the local state. The logic is straight-forward\n    //\tas we need to track:\n    //\t\t1. The composed set of unacknowledged locally generated events.\n    //\t\t2. The composed set of unsent locally generated events (queued until sent event is acknowledged).\n    //\t\t3. The local state.\n    //\t\t4. An undo operation.\n    //\n    OTClientEngine.prototype.addLocal = function (orig) {\n        try {\n            this.actionAllClient.compose(orig);\n            this.actionAllPendingClient.compose(orig);\n            this.stateLocal.compose(orig);\n        }\n        catch (err) {\n            this.context.log(0, \"OTClientEngine.addLocal: unexpected exception: \" + err);\n            this.failbackToServerState();\n        }\n    };\n    return OTClientEngine;\n}());\nexports.OTClientEngine = OTClientEngine;\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/otclientengine.ts\n ** module id = 3\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:///lib/otclientengine.ts","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OT = require(\"./ottypes\");\nvar OTA = require(\"./otarray\");\nvar OTM = require(\"./otmap\");\nvar OTC = require(\"./otcounter\");\nexports.clockSuccess = 0;\nexports.clockInitialValue = -1; // Initial value\nexports.clockTerminateValue = -2; // Terminal action from client.\nexports.clockRandomizeValue = -3; // Fill in with random data.\nexports.clockFailureValue = -4; // Server failed to apply.\nexports.clockInitializeValue = -5; // Used to initialize client to a specific string value.\nexports.clockUndoValue = -6; // Used to indicate we should generate an undo event.\nexports.clockSeenValue = -7; // Server has already seen this event\nvar OTCompositeResource = (function (_super) {\n    __extends(OTCompositeResource, _super);\n    function OTCompositeResource(rid, cid) {\n        _super.call(this, 'root', 'composite');\n        this.resourceID = rid;\n        this.clientID = cid;\n        this.clock = exports.clockInitialValue;\n        this.clientSequenceNo = 0;\n    }\n    OTCompositeResource.registerType = function (underlyingType, factory) {\n        if (OTCompositeResource.typeRegistry == null)\n            OTCompositeResource.typeRegistry = {};\n        OTCompositeResource.typeRegistry[underlyingType] = factory;\n    };\n    OTCompositeResource.prototype.findResource = function (rname, utype, bConstruct) {\n        if (utype === void 0) { utype = ''; }\n        if (bConstruct === void 0) { bConstruct = false; }\n        for (var i = 0; i < this.length; i++)\n            if (this.edits[i].resourceName === rname)\n                return this.edits[i];\n        if (bConstruct) {\n            var edit = OTCompositeResource.constructResource(rname, utype);\n            this.edits.push(edit);\n            return edit;\n        }\n        else\n            return null;\n    };\n    OTCompositeResource.prototype.isEmpty = function () {\n        // Canonical empty is an empty edits array, but an array of empty edits is always considered empty\n        for (var i = 0; i < this.length; i++)\n            if (!this.edits[i].isEmpty())\n                return false;\n        return true;\n    };\n    // Copy an instance\n    OTCompositeResource.prototype.copy = function () {\n        var c = new OTCompositeResource(this.resourceID, this.clientID);\n        c.clock = this.clock;\n        c.clientSequenceNo = this.clientSequenceNo;\n        for (var i = 0; i < this.length; i++)\n            c.edits.push(this.edits[i].copy());\n        return c;\n    };\n    // Test whether two operations are effectively equivalent\n    OTCompositeResource.prototype.effectivelyEqual = function (rhs) {\n        // This should really be a structural error\n        if (this.length != rhs.length)\n            return false;\n        for (var i = 0; i < this.length; i++) {\n            var lhsEdit = this.edits[i];\n            var rhsEdit = rhs.findResource(lhsEdit.resourceName);\n            if ((rhsEdit == null && !lhsEdit.isEmpty()) || !lhsEdit.effectivelyEqual(rhsEdit))\n                return false;\n        }\n        return true;\n    };\n    // Core OT algorithm for this type\n    OTCompositeResource.prototype.transform = function (rhs, bPriorIsService) {\n        for (var i = 0; i < rhs.length; i++) {\n            var rhsEdit = rhs.edits[i];\n            var lhsEdit = this.findResource(rhsEdit.resourceName, rhsEdit.underlyingType, false);\n            if (lhsEdit)\n                lhsEdit.transform(rhsEdit, bPriorIsService);\n        }\n    };\n    // compose two edit actions\n    OTCompositeResource.prototype.compose = function (rhs) {\n        for (var i = 0; i < rhs.length; i++) {\n            var rhsEdit = rhs.edits[i];\n            var lhsEdit = this.findResource(rhsEdit.resourceName, rhsEdit.underlyingType, !rhsEdit.isEmpty());\n            if (lhsEdit)\n                lhsEdit.compose(rhsEdit);\n        }\n        this.clock = rhs.clock;\n        this.clientSequenceNo = rhs.clientSequenceNo;\n    };\n    // apply this edit to an existing value, returning new value (if underlying type is mutable, may modify input)\n    // For composite, takes array of values, returns array of results, one for each underlying resource.\n    OTCompositeResource.prototype.apply = function (runningValue) {\n        if (runningValue == null)\n            runningValue = {};\n        for (var i = 0; i < this.length; i++) {\n            var e = this.edits[i];\n            runningValue[e.resourceName] = e.apply(runningValue[e.resourceName]);\n        }\n        return runningValue;\n    };\n    OTCompositeResource.prototype.toValue = function () {\n        return this.apply(null);\n    };\n    OTCompositeResource.prototype.minimize = function () {\n        for (var i = 0; i < this.length; i++)\n            this.edits[i].minimize();\n    };\n    OTCompositeResource.constructResource = function (rname, utype) {\n        if (OTCompositeResource.typeRegistry == null) {\n            //throw \"OTCompositeResource.constructResource: no registered factories\";\n            // This is only place where Composite type knows of other types - could hoist to outer level\n            OTCompositeResource.registerType('string', OTA.OTStringResource.factory);\n            OTCompositeResource.registerType('array', OTA.OTArrayResource.factory);\n            OTCompositeResource.registerType('map', OTM.OTMapResource.factory);\n            OTCompositeResource.registerType('counter', OTC.OTCounterResource.factory);\n        }\n        var factory = OTCompositeResource.typeRegistry[utype];\n        if (factory == null)\n            throw \"OTCompositeResource.constructResource: no registered factory for \" + utype;\n        return factory(rname);\n    };\n    // Deserialization\n    OTCompositeResource.constructFromObject = function (o) {\n        var cedit = new OTCompositeResource(\"\", \"\");\n        if (o['resourceID'] !== undefined)\n            cedit.resourceID = o['resourceID'];\n        if (o['clientID'] !== undefined)\n            cedit.clientID = o['clientID'];\n        if (o['clock'] !== undefined)\n            cedit.clock = Number(o['clock']);\n        if (o['clientSequenceNo'] !== undefined)\n            cedit.clientSequenceNo = Number(o['clientSequenceNo']);\n        if (o['edits'] !== undefined) {\n            var arrEdits = o['edits'];\n            for (var i = 0; i < arrEdits.length; i++) {\n                var a = arrEdits[i];\n                var rname = a['resourceName'];\n                var utype = a['underlyingType'];\n                var edit = this.constructResource(rname, utype);\n                edit.edits = a['edits'];\n                cedit.edits.push(edit);\n            }\n        }\n        return cedit;\n    };\n    // Serialization\n    OTCompositeResource.prototype.toJSON = function () {\n        var o = {\n            \"resourceID\": this.resourceID,\n            \"clientID\": this.clientID,\n            \"clock\": this.clock,\n            \"clientSequenceNo\": this.clientSequenceNo,\n            \"edits\": [] };\n        for (var i = 0; i < this.length; i++) {\n            var edit = this.edits[i];\n            var oEdit = { \"resourceName\": edit.resourceName, \"underlyingType\": edit.underlyingType, \"edits\": edit.edits };\n            o[\"edits\"].push(oEdit);\n        }\n        return o;\n    };\n    return OTCompositeResource;\n}(OT.OTResourceBase));\nexports.OTCompositeResource = OTCompositeResource;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/otcomposite.ts\n ** module id = 4\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:///lib/otcomposite.ts","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OT = require(\"./ottypes\");\n// This implements OT for a dictionary of objects. OT is pretty trivial for maps - last wins.\nexports.OpMapSet = 1;\nexports.OpMapDel = 2;\nvar OTMapResource = (function (_super) {\n    __extends(OTMapResource, _super);\n    function OTMapResource(rid) {\n        _super.call(this, rid, 'map');\n    }\n    OTMapResource.factory = function (rid) { return new OTMapResource(rid); };\n    // copy an instance\n    OTMapResource.prototype.copy = function () {\n        var c = new OTMapResource(this.resourceName);\n        for (var i = 0; i < this.length; i++) {\n            var e = this.edits[i];\n            c.edits.push([e[0], e[1], e[2]]);\n        }\n        return c;\n    };\n    // Test whether two operations are effectively equivalent\n    OTMapResource.prototype.effectivelyEqual = function (rhs) {\n        // This should really be a structural error\n        if (this.length != rhs.length)\n            return false;\n        // This checks for exact structural equivalency. Really the ordering shouldn't matter for Map so\n        // an improvement to this algorithm would be to be more robust to ordering differences.\n        for (var i = 0; i < this.length; i++) {\n            var e1 = this.edits[i];\n            var e2 = rhs.edits[i];\n            if (e1[0] != e2[0] || e1[1] != e2[1] || e1[2] != e2[2])\n                return false;\n        }\n        return true;\n    };\n    // Core OT algorithm for this type\n    OTMapResource.prototype.transform = function (prior, bPriorIsService) {\n        // Last wins - if I'm last, my sets and deletes are all preserved\n        if (bPriorIsService)\n            return;\n        // OK, remove any operations (either sets or deletes), that conflict with me\n        // First load in my properties\n        var myEdits = this.toObject();\n        // Now delete any that are overridden\n        for (var i = 0; i < prior.length; i++)\n            delete myEdits[(prior.edits[i])[1]];\n        // Now restore edit array from edited object\n        this.fromObject(myEdits);\n    };\n    // compose two edit actions\n    OTMapResource.prototype.compose = function (rhs) {\n        var o = this.toObject();\n        for (var i = 0; i < rhs.length; i++) {\n            var eR = rhs.edits[i];\n            o[eR[1]] = [eR[0], eR[1], eR[2]]; // Note this overwrites any existing operation on this key, set or del\n        }\n        this.fromObject(o);\n    };\n    OTMapResource.prototype.apply = function (startValue) {\n        if (startValue == null)\n            startValue = {};\n        for (var i = 0; i < this.length; i++) {\n            var e = this.edits[i];\n            switch (e[0]) {\n                case exports.OpMapSet:\n                    startValue[e[1]] = e[2];\n                    break;\n                case exports.OpMapDel:\n                    delete startValue[e[1]];\n                    break;\n            }\n        }\n        return startValue;\n    };\n    OTMapResource.prototype.minimize = function () {\n        // Effectively removes OpMapDel\n        var o = this.apply({});\n        this.edits = [];\n        for (var p in o)\n            if (o.hasOwnProperty(p))\n                this.edits.push([exports.OpMapSet, p, o[p]]);\n    };\n    OTMapResource.prototype.loadObject = function (o) {\n        for (var i = 0; i < this.length; i++)\n            o[(this.edits[i])[1]] = this.edits[i];\n        return o;\n    };\n    OTMapResource.prototype.toObject = function () {\n        return this.loadObject({});\n    };\n    OTMapResource.prototype.fromObject = function (o) {\n        this.edits = [];\n        for (var p in o)\n            if (o.hasOwnProperty(p))\n                this.edits.push(o[p]);\n    };\n    return OTMapResource;\n}(OT.OTResourceBase));\nexports.OTMapResource = OTMapResource;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/otmap.ts\n ** module id = 5\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:///lib/otmap.ts","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OT = require(\"./ottypes\");\n// This implements OT for a simple map of counters. Instead of a new value replacing the \n// keyed value, values are added together. This allows a simple accumulating counter.\n// Possible future additions:\n//\tAdd additional semantics for how the values accumulate. Examples from DropBox's datastore API\n//\tincluded \"min\" and \"max\" as alternate rules to \"sum\".\n//\nexports.OpCounterAdd = 1;\nexports.OpCounterDel = 2;\nvar OTCounterResource = (function (_super) {\n    __extends(OTCounterResource, _super);\n    function OTCounterResource(rid) {\n        _super.call(this, rid, 'map');\n    }\n    OTCounterResource.factory = function (rid) { return new OTCounterResource(rid); };\n    // copy an instance\n    OTCounterResource.prototype.copy = function () {\n        var c = new OTCounterResource(this.resourceName);\n        for (var i = 0; i < this.length; i++) {\n            var e = this.edits[i];\n            c.edits.push([e[0], e[1], e[2]]);\n        }\n        return c;\n    };\n    // Test whether two operations are effectively equivalent\n    OTCounterResource.prototype.effectivelyEqual = function (rhs) {\n        // This should really be a structural error\n        if (this.length != rhs.length)\n            return false;\n        // This checks for exact structural equivalency. Really the ordering shouldn't matter for Counter so\n        // an improvement to this algorithm would be to be more robust to ordering differences.\n        for (var i = 0; i < this.length; i++) {\n            var e1 = this.edits[i];\n            var e2 = rhs.edits[i];\n            if (e1[0] != e2[0] || e1[1] != e2[1] || e1[2] != e2[2])\n                return false;\n        }\n        return true;\n    };\n    // Core OT algorithm for this type\n    OTCounterResource.prototype.transform = function (prior, bPriorIsService) {\n        // Last wins - if I'm last, my adds and deletes are all preserved\n        if (bPriorIsService)\n            return;\n        // Deletes in prior will delete mine. Implement by loading up properties rather than\n        // using N^2 lookup through Edits array.\n        var myEdits = this.toObject();\n        var bEdited = false;\n        // Now delete any that are deleted by prior.\n        for (var i = 0; i < prior.length; i++) {\n            var eP = prior.edits[i];\n            if (eP[0] == exports.OpCounterDel) {\n                delete myEdits[eP[1]];\n                bEdited = true;\n            }\n        }\n        // Now restore edit array from edited object\n        if (bEdited)\n            this.fromObject(myEdits);\n    };\n    // compose two edit actions\n    OTCounterResource.prototype.compose = function (rhs) {\n        var lhsKeys = this.toObject();\n        var rhsKeys = rhs.toObject();\n        for (var i = 0; i < rhs.length; i++) {\n            var eR = rhsKeys.edits[i];\n            var eL = lhsKeys[eR[1]];\n            if (eL === undefined)\n                lhsKeys[eR[1]] = [eR[0], eR[1], eR[2]];\n            else\n                eL[2] += eR[2];\n        }\n        this.fromObject(lhsKeys);\n    };\n    OTCounterResource.prototype.apply = function (startValue) {\n        if (startValue == null)\n            startValue = {};\n        for (var i = 0; i < this.length; i++) {\n            var e = this.edits[i];\n            switch (e[0]) {\n                case exports.OpCounterAdd:\n                    if (startValue[e[1]] === undefined)\n                        startValue[e[1]] = e[2];\n                    else\n                        startValue[e[1]] += e[2];\n                    break;\n                case exports.OpCounterDel:\n                    delete startValue[e[1]];\n                    break;\n            }\n        }\n        return startValue;\n    };\n    OTCounterResource.prototype.minimize = function () {\n        // No-op\n    };\n    OTCounterResource.prototype.loadObject = function (o) {\n        for (var i = 0; i < this.length; i++)\n            o[(this.edits[i])[1]] = this.edits[i];\n        return o;\n    };\n    OTCounterResource.prototype.toObject = function () {\n        return this.loadObject({});\n    };\n    OTCounterResource.prototype.fromObject = function (o) {\n        this.edits = [];\n        for (var p in o)\n            if (o.hasOwnProperty(p))\n                this.edits.push(o[p]);\n    };\n    return OTCounterResource;\n}(OT.OTResourceBase));\nexports.OTCounterResource = OTCounterResource;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/otcounter.ts\n ** module id = 6\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:///lib/otcounter.ts","\"use strict\";\nvar OTC = require(\"./otcomposite\");\nvar OTServerEngine = (function () {\n    // Constructor\n    function OTServerEngine(ctx, rid) {\n        this.context = ctx;\n        this.stateServer = new OTC.OTCompositeResource(rid, \"\");\n        this.logServer = [];\n        this.highSequence = {};\n    }\n    OTServerEngine.prototype.serverClock = function () {\n        return this.stateServer.clock;\n    };\n    OTServerEngine.prototype.toValue = function () {\n        return this.stateServer.toValue();\n    };\n    OTServerEngine.prototype.hasSeenEvent = function (orig) {\n        var clientSequenceNo = this.highSequence[orig.clientID];\n        return (clientSequenceNo !== undefined && Number(clientSequenceNo) >= orig.clientSequenceNo);\n    };\n    OTServerEngine.prototype.isNextEvent = function (orig) {\n        var clientSequenceNo = this.highSequence[orig.clientID];\n        return (clientSequenceNo === undefined && orig.clientSequenceNo == 0)\n            || (Number(clientSequenceNo) + 1 == orig.clientSequenceNo);\n    };\n    OTServerEngine.prototype.rememberSeenEvent = function (orig) {\n        this.highSequence[orig.clientID] = orig.clientSequenceNo;\n    };\n    OTServerEngine.prototype.forgetEvents = function (orig) {\n        delete this.highSequence[orig.clientID];\n    };\n    // Function: addServer\n    //\n    // Description:\n    //\tThis is the server state update processing upon receiving an event from an endpoint.\n    //\tThe received event is transformed (if possible) and added to the server state.\n    //\tThe logic here is straight-forward - transform the incoming event so it is relative to\n    //\tthe current state and then apply.\n    OTServerEngine.prototype.addServer = function (orig) {\n        this.context.log(10, \"addServer: Event clientID: \" + orig.clientID + \" clock: \" + orig.clock);\n        try {\n            // First transform, then add to log\n            var i = void 0;\n            var a = orig.copy();\n            for (i = this.logServer.length; i > 0; i--) {\n                var aService = this.logServer[i - 1];\n                if (aService.clock == a.clock)\n                    break;\n            }\n            // Fail if we've seen it already (client did not receive ack)\n            if (this.hasSeenEvent(orig)) {\n                this.context.log(0, \"addServer: received duplicate event.\");\n                return OTC.clockSeenValue;\n            }\n            // If this isn't next in sequence, I lost one (probably because I went \"back in time\"\n            // due to server restart). In that case client is forced to re-initialize (losing local\n            // edits). I also need to re-initialize sequence numbering.\n            if (!this.isNextEvent(orig)) {\n                this.context.log(0, \"addServer: received out-of-order event.\");\n                this.forgetEvents(orig);\n                return OTC.clockInitialValue;\n            }\n            // Fail if we have discarded that old state\n            if (a.clock >= 0 && i == 0) {\n                this.context.log(0, \"addServer: received old event.\");\n                return OTC.clockFailureValue;\n            }\n            // OK, all good, transform and apply\n            if (i < this.logServer.length) {\n                var aPrior = this.logServer[i].copy();\n                for (i++; i < this.logServer.length; i++)\n                    aPrior.compose(this.logServer[i]);\n                a.transform(aPrior, true);\n            }\n            a.clock = this.stateServer.clock + 1;\n            this.stateServer.compose(a);\n            this.logServer.push(a.copy());\n            this.rememberSeenEvent(orig);\n            return OTC.clockSuccess;\n        }\n        catch (err) {\n            return OTC.clockFailureValue;\n        }\n    };\n    OTServerEngine.prototype.toJSON = function () {\n        return { state: this.stateServer.toJSON(), highSequence: this.highSequence };\n    };\n    OTServerEngine.prototype.loadFromObject = function (o) {\n        if (o.state !== undefined) {\n            this.stateServer = OTC.OTCompositeResource.constructFromObject(o.state);\n            this.logServer.push(this.stateServer.copy());\n        }\n        if (o.highSequence !== undefined)\n            this.highSequence = o.highSequence;\n    };\n    return OTServerEngine;\n}());\nexports.OTServerEngine = OTServerEngine;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/otserverengine.ts\n ** module id = 7\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:///lib/otserverengine.ts"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5eeb9f8b798a1820ab78\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:/webpack/bootstrap 5eeb9f8b798a1820ab78","\"use strict\";\nvar OT = require(\"@terrencecrowley/ot-js\");\nvar DMP = require(\"diff-match-patch\");\nvar DiffMatchPatch = new DMP.diff_match_patch();\nvar DIFF_DELETE = DMP.DIFF_DELETE;\nvar DIFF_INSERT = DMP.DIFF_INSERT;\nvar DIFF_EQUAL = DMP.DIFF_EQUAL;\nvar OTEditUtil = (function () {\n    // Constructor\n    function OTEditUtil(ctx, rid, cid, name) {\n        this.context = ctx;\n        this.resourceID = rid;\n        this.clientID = cid;\n        this.resourceName = name;\n    }\n    //\n    // Function: insertAtStart\n    //\n    // Description:\n    //\tGenerate an OTCompositeResource to insert a string at the start of a buffer of the given size.\n    //\n    OTEditUtil.prototype.insertAtStart = function (s, nCurrentLen) {\n        var edit = new OT.OTCompositeResource(this.resourceID, this.clientID);\n        var sEdit = new OT.OTStringResource(this.resourceName);\n        sEdit.edits.push([OT.OpInsert, s.length, s]);\n        sEdit.edits.push([OT.OpCursor, 0, '']);\n        sEdit.edits.push([OT.OpRetain, nCurrentLen, '']);\n        edit.edits.push(sEdit);\n        return edit;\n    };\n    //\n    // Function: insertAtEnd\n    //\n    // Description:\n    //\tGenerate an OTCompositeResource to insert a string at the end of a buffer of the given size.\n    //\n    OTEditUtil.prototype.insertAtEnd = function (s, nCurrentLen) {\n        var edit = new OT.OTCompositeResource(this.resourceID, this.clientID);\n        var sEdit = new OT.OTStringResource(this.resourceName);\n        sEdit.edits.push([OT.OpRetain, nCurrentLen, '']);\n        sEdit.edits.push([OT.OpInsert, s.length, s]);\n        sEdit.edits.push([OT.OpCursor, 0, '']);\n        edit.edits.push(sEdit);\n        return edit;\n    };\n    //\n    // Function: injectCursor\n    //\n    // Inject start/end cursor positions into an existing string resource.\n    //\n    OTEditUtil.prototype.injectCursor = function (edit, start, end) {\n        if (start === undefined)\n            return;\n        if (end === undefined)\n            end = start;\n        var sEdit = edit.findResource(this.resourceName);\n        if (sEdit == null)\n            return;\n        var cEdit = new OT.OTStringResource(this.resourceName);\n        if (start != 0)\n            cEdit.edits.push([OT.OpRetain, start, '']);\n        cEdit.edits.push([OT.OpCursor, 0, this.clientID]);\n        if (end != start) {\n            cEdit.edits.push([OT.OpRetain, end - start, '']);\n            cEdit.edits.push([OT.OpCursor, 1, this.clientID]);\n        }\n        var nFinal = sEdit.finalLength();\n        if (end != nFinal)\n            cEdit.edits.push([OT.OpRetain, nFinal - end, '']);\n        sEdit.compose(cEdit);\n    };\n    //\n    // Function: extractCursor\n    //\n    // Extract cursor information by client. Returns an object indexed by clientID with an object with\n    // properties startSelection, endSelection.\n    //\n    OTEditUtil.prototype.extractCursor = function (edit) {\n        var cursors = {};\n        var sEdit = edit.findResource(this.resourceName);\n        if (sEdit == null)\n            return cursors;\n        var pos = 0;\n        for (var i = 0; i < sEdit.length; i++) {\n            var a = sEdit.edits[i];\n            switch (a[0]) {\n                case OT.OpInsert:\n                    pos += a[1];\n                    break;\n                case OT.OpDelete:\n                    break;\n                case OT.OpRetain:\n                    pos += a[1];\n                    break;\n                case OT.OpCursor:\n                    if (a[2] != '') {\n                        var sel = cursors[a[2]]; // a[2] is clientID\n                        if (sel === undefined) {\n                            sel = {};\n                            cursors[a[2]] = sel;\n                        }\n                        if (a[1] == 0)\n                            sel['selectionStart'] = pos; // 0 is selectionStart\n                        else\n                            sel['selectionEnd'] = pos; // 1 is selectionEnd\n                    }\n                    break;\n                case OT.OpSet:\n                    pos += a[1];\n                    break;\n            }\n        }\n        return cursors;\n    };\n    //\n    // Function: computeEdit\n    //\n    // Description:\n    //\tGiven an old and new string, generate the (minimal) edits list necessary to convert the old\n    //\tstring into the new string.\n    //\n    // \tThis is useful if you're not actually tracking the specfic edit operations happening to the\n    //\tunderlying string but rather just examining old and new values and trying to transmit\n    //\tminimal diffs.\n    //\n    //\tThere are various good algorithms for computing the \"edit distance\" between two strings.\n    //\tHere I've used the google DiffMatchPatch algorithm.\n    //\n    OTEditUtil.prototype.computeEdit = function (sOld, sNew) {\n        var edit = new OT.OTCompositeResource(this.resourceID, this.clientID);\n        var sEdit = new OT.OTStringResource(this.resourceName);\n        var diffs = DiffMatchPatch.diff_main(sOld, sNew);\n        if (diffs)\n            for (var i = 0; i < diffs.length; i++) {\n                var diff = diffs[i];\n                var s = diff[1];\n                switch (diff[0]) {\n                    case DIFF_DELETE:\n                        sEdit.edits.push([OT.OpDelete, s.length, '']);\n                        break;\n                    case DIFF_INSERT:\n                        sEdit.edits.push([OT.OpInsert, s.length, s]);\n                        break;\n                    case DIFF_EQUAL:\n                        sEdit.edits.push([OT.OpRetain, s.length, '']);\n                        break;\n                }\n            }\n        edit.edits.push(sEdit);\n        return edit;\n    };\n    return OTEditUtil;\n}());\nexports.OTEditUtil = OTEditUtil;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/oteditutil.ts\n ** module id = 0\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:///lib/oteditutil.ts","module.exports = require(\"@terrencecrowley/ot-js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"@terrencecrowley/ot-js\"\n ** module id = 1\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:/external \"@terrencecrowley/ot-js\"","module.exports = require(\"diff-match-patch\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"diff-match-patch\"\n ** module id = 2\n ** module chunks = 0\n **/\n\n\n// WEBPACK FOOTER //\n// webpack:/external \"diff-match-patch\"","'use strict'\r\n\r\n/**\r\n * Diff Match and Patch\r\n *\r\n * Copyright 2006 Google Inc.\r\n * http://code.google.com/p/google-diff-match-patch/\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @fileoverview Computes the difference between two texts to create a patch.\r\n * Applies the patch onto another text, allowing for errors.\r\n * @author fraser@google.com (Neil Fraser)\r\n */\r\n\r\n/**\r\n * Class containing the diff, match and patch methods.\r\n * @constructor\r\n */\r\nfunction diff_match_patch() {\r\n\r\n  // Defaults.\r\n  // Redefine these in your program to override the defaults.\r\n\r\n  // Number of seconds to map a diff before giving up (0 for infinity).\r\n  this.Diff_Timeout = 1.0;\r\n  // Cost of an empty edit operation in terms of edit characters.\r\n  this.Diff_EditCost = 4;\r\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\r\n  this.Match_Threshold = 0.5;\r\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\r\n  // A match this many characters away from the expected location will add\r\n  // 1.0 to the score (0.0 is a perfect match).\r\n  this.Match_Distance = 1000;\r\n  // When deleting a large block of text (over ~64 characters), how close do\r\n  // the contents have to be to match the expected contents. (0.0 = perfection,\r\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\r\n  // end points of a delete need to match.\r\n  this.Patch_DeleteThreshold = 0.5;\r\n  // Chunk size for context length.\r\n  this.Patch_Margin = 4;\r\n\r\n  // The number of bits in an int.\r\n  this.Match_MaxBits = 32;\r\n}\r\n\r\n\r\n//  DIFF FUNCTIONS\r\n\r\n\r\n/**\r\n * The data structure representing a diff is an array of tuples:\r\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\r\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\r\n */\r\nvar DIFF_DELETE = -1;\r\nvar DIFF_INSERT = 1;\r\nvar DIFF_EQUAL = 0;\r\n\r\n/** @typedef {{0: number, 1: string}} */\r\ndiff_match_patch.Diff;\r\n\r\n\r\n/**\r\n * Find the differences between two texts.  Simplifies the problem by stripping\r\n * any common prefix or suffix off the texts before diffing.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\r\n *     then don't run a line-level diff first to identify the changed areas.\r\n *     Defaults to true, which does a faster, slightly less optimal diff.\r\n * @param {number} opt_deadline Optional time when the diff should be complete\r\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\r\n *     instead.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\r\n    opt_deadline) {\r\n  // Set a deadline by which time the diff must be complete.\r\n  if (typeof opt_deadline == 'undefined') {\r\n    if (this.Diff_Timeout <= 0) {\r\n      opt_deadline = Number.MAX_VALUE;\r\n    } else {\r\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\r\n    }\r\n  }\r\n  var deadline = opt_deadline;\r\n\r\n  // Check for null inputs.\r\n  if (text1 == null || text2 == null) {\r\n    throw new Error('Null input. (diff_main)');\r\n  }\r\n\r\n  // Check for equality (speedup).\r\n  if (text1 == text2) {\r\n    if (text1) {\r\n      return [[DIFF_EQUAL, text1]];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  if (typeof opt_checklines == 'undefined') {\r\n    opt_checklines = true;\r\n  }\r\n  var checklines = opt_checklines;\r\n\r\n  // Trim off common prefix (speedup).\r\n  var commonlength = this.diff_commonPrefix(text1, text2);\r\n  var commonprefix = text1.substring(0, commonlength);\r\n  text1 = text1.substring(commonlength);\r\n  text2 = text2.substring(commonlength);\r\n\r\n  // Trim off common suffix (speedup).\r\n  commonlength = this.diff_commonSuffix(text1, text2);\r\n  var commonsuffix = text1.substring(text1.length - commonlength);\r\n  text1 = text1.substring(0, text1.length - commonlength);\r\n  text2 = text2.substring(0, text2.length - commonlength);\r\n\r\n  // Compute the diff on the middle block.\r\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\r\n\r\n  // Restore the prefix and suffix.\r\n  if (commonprefix) {\r\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\r\n  }\r\n  if (commonsuffix) {\r\n    diffs.push([DIFF_EQUAL, commonsuffix]);\r\n  }\r\n  this.diff_cleanupMerge(diffs);\r\n  return diffs;\r\n};\r\n\r\n\r\n/**\r\n * Find the differences between two texts.  Assumes that the texts do not\r\n * have any common prefix or suffix.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\r\n *     line-level diff first to identify the changed areas.\r\n *     If true, then run a faster, slightly less optimal diff.\r\n * @param {number} deadline Time when the diff should be complete by.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\r\n    deadline) {\r\n  var diffs;\r\n\r\n  if (!text1) {\r\n    // Just add some text (speedup).\r\n    return [[DIFF_INSERT, text2]];\r\n  }\r\n\r\n  if (!text2) {\r\n    // Just delete some text (speedup).\r\n    return [[DIFF_DELETE, text1]];\r\n  }\r\n\r\n  var longtext = text1.length > text2.length ? text1 : text2;\r\n  var shorttext = text1.length > text2.length ? text2 : text1;\r\n  var i = longtext.indexOf(shorttext);\r\n  if (i != -1) {\r\n    // Shorter text is inside the longer text (speedup).\r\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\r\n             [DIFF_EQUAL, shorttext],\r\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\r\n    // Swap insertions for deletions if diff is reversed.\r\n    if (text1.length > text2.length) {\r\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\r\n    }\r\n    return diffs;\r\n  }\r\n\r\n  if (shorttext.length == 1) {\r\n    // Single character string.\r\n    // After the previous speedup, the character can't be an equality.\r\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n  }\r\n\r\n  // Check to see if the problem can be split in two.\r\n  var hm = this.diff_halfMatch_(text1, text2);\r\n  if (hm) {\r\n    // A half-match was found, sort out the return data.\r\n    var text1_a = hm[0];\r\n    var text1_b = hm[1];\r\n    var text2_a = hm[2];\r\n    var text2_b = hm[3];\r\n    var mid_common = hm[4];\r\n    // Send both pairs off for separate processing.\r\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\r\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\r\n    // Merge the results.\r\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\r\n  }\r\n\r\n  if (checklines && text1.length > 100 && text2.length > 100) {\r\n    return this.diff_lineMode_(text1, text2, deadline);\r\n  }\r\n\r\n  return this.diff_bisect_(text1, text2, deadline);\r\n};\r\n\r\n\r\n/**\r\n * Do a quick line-level diff on both strings, then rediff the parts for\r\n * greater accuracy.\r\n * This speedup can produce non-minimal diffs.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} deadline Time when the diff should be complete by.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\r\n  // Scan the text on a line-by-line basis first.\r\n  var a = this.diff_linesToChars_(text1, text2);\r\n  text1 = a.chars1;\r\n  text2 = a.chars2;\r\n  var linearray = a.lineArray;\r\n\r\n  var diffs = this.diff_main(text1, text2, false, deadline);\r\n\r\n  // Convert the diff back to original text.\r\n  this.diff_charsToLines_(diffs, linearray);\r\n  // Eliminate freak matches (e.g. blank lines)\r\n  this.diff_cleanupSemantic(diffs);\r\n\r\n  // Rediff any replacement blocks, this time character-by-character.\r\n  // Add a dummy entry at the end.\r\n  diffs.push([DIFF_EQUAL, '']);\r\n  var pointer = 0;\r\n  var count_delete = 0;\r\n  var count_insert = 0;\r\n  var text_delete = '';\r\n  var text_insert = '';\r\n  while (pointer < diffs.length) {\r\n    switch (diffs[pointer][0]) {\r\n      case DIFF_INSERT:\r\n        count_insert++;\r\n        text_insert += diffs[pointer][1];\r\n        break;\r\n      case DIFF_DELETE:\r\n        count_delete++;\r\n        text_delete += diffs[pointer][1];\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // Upon reaching an equality, check for prior redundancies.\r\n        if (count_delete >= 1 && count_insert >= 1) {\r\n          // Delete the offending records and add the merged ones.\r\n          diffs.splice(pointer - count_delete - count_insert,\r\n                       count_delete + count_insert);\r\n          pointer = pointer - count_delete - count_insert;\r\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\r\n          for (var j = a.length - 1; j >= 0; j--) {\r\n            diffs.splice(pointer, 0, a[j]);\r\n          }\r\n          pointer = pointer + a.length;\r\n        }\r\n        count_insert = 0;\r\n        count_delete = 0;\r\n        text_delete = '';\r\n        text_insert = '';\r\n        break;\r\n    }\r\n    pointer++;\r\n  }\r\n  diffs.pop();  // Remove the dummy entry at the end.\r\n\r\n  return diffs;\r\n};\r\n\r\n\r\n/**\r\n * Find the 'middle snake' of a diff, split the problem in two\r\n * and return the recursively constructed diff.\r\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} deadline Time at which to bail if not yet complete.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\r\n  // Cache the text lengths to prevent multiple calls.\r\n  var text1_length = text1.length;\r\n  var text2_length = text2.length;\r\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\r\n  var v_offset = max_d;\r\n  var v_length = 2 * max_d;\r\n  var v1 = new Array(v_length);\r\n  var v2 = new Array(v_length);\r\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\r\n  // integers and undefined.\r\n  for (var x = 0; x < v_length; x++) {\r\n    v1[x] = -1;\r\n    v2[x] = -1;\r\n  }\r\n  v1[v_offset + 1] = 0;\r\n  v2[v_offset + 1] = 0;\r\n  var delta = text1_length - text2_length;\r\n  // If the total number of characters is odd, then the front path will collide\r\n  // with the reverse path.\r\n  var front = (delta % 2 != 0);\r\n  // Offsets for start and end of k loop.\r\n  // Prevents mapping of space beyond the grid.\r\n  var k1start = 0;\r\n  var k1end = 0;\r\n  var k2start = 0;\r\n  var k2end = 0;\r\n  for (var d = 0; d < max_d; d++) {\r\n    // Bail out if deadline is reached.\r\n    if ((new Date()).getTime() > deadline) {\r\n      break;\r\n    }\r\n\r\n    // Walk the front path one step.\r\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\r\n      var k1_offset = v_offset + k1;\r\n      var x1;\r\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\r\n        x1 = v1[k1_offset + 1];\r\n      } else {\r\n        x1 = v1[k1_offset - 1] + 1;\r\n      }\r\n      var y1 = x1 - k1;\r\n      while (x1 < text1_length && y1 < text2_length &&\r\n             text1.charAt(x1) == text2.charAt(y1)) {\r\n        x1++;\r\n        y1++;\r\n      }\r\n      v1[k1_offset] = x1;\r\n      if (x1 > text1_length) {\r\n        // Ran off the right of the graph.\r\n        k1end += 2;\r\n      } else if (y1 > text2_length) {\r\n        // Ran off the bottom of the graph.\r\n        k1start += 2;\r\n      } else if (front) {\r\n        var k2_offset = v_offset + delta - k1;\r\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\r\n          // Mirror x2 onto top-left coordinate system.\r\n          var x2 = text1_length - v2[k2_offset];\r\n          if (x1 >= x2) {\r\n            // Overlap detected.\r\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Walk the reverse path one step.\r\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\r\n      var k2_offset = v_offset + k2;\r\n      var x2;\r\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\r\n        x2 = v2[k2_offset + 1];\r\n      } else {\r\n        x2 = v2[k2_offset - 1] + 1;\r\n      }\r\n      var y2 = x2 - k2;\r\n      while (x2 < text1_length && y2 < text2_length &&\r\n             text1.charAt(text1_length - x2 - 1) ==\r\n             text2.charAt(text2_length - y2 - 1)) {\r\n        x2++;\r\n        y2++;\r\n      }\r\n      v2[k2_offset] = x2;\r\n      if (x2 > text1_length) {\r\n        // Ran off the left of the graph.\r\n        k2end += 2;\r\n      } else if (y2 > text2_length) {\r\n        // Ran off the top of the graph.\r\n        k2start += 2;\r\n      } else if (!front) {\r\n        var k1_offset = v_offset + delta - k2;\r\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\r\n          var x1 = v1[k1_offset];\r\n          var y1 = v_offset + x1 - k1_offset;\r\n          // Mirror x2 onto top-left coordinate system.\r\n          x2 = text1_length - x2;\r\n          if (x1 >= x2) {\r\n            // Overlap detected.\r\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Diff took too long and hit the deadline or\r\n  // number of diffs equals number of characters, no commonality at all.\r\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n};\r\n\r\n\r\n/**\r\n * Given the location of the 'middle snake', split the diff in two parts\r\n * and recurse.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} x Index of split point in text1.\r\n * @param {number} y Index of split point in text2.\r\n * @param {number} deadline Time at which to bail if not yet complete.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\r\n    deadline) {\r\n  var text1a = text1.substring(0, x);\r\n  var text2a = text2.substring(0, y);\r\n  var text1b = text1.substring(x);\r\n  var text2b = text2.substring(y);\r\n\r\n  // Compute both diffs serially.\r\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\r\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\r\n\r\n  return diffs.concat(diffsb);\r\n};\r\n\r\n\r\n/**\r\n * Split two texts into an array of strings.  Reduce the texts to a string of\r\n * hashes where each Unicode character represents one line.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\r\n *     An object containing the encoded text1, the encoded text2 and\r\n *     the array of unique strings.\r\n *     The zeroth element of the array of unique strings is intentionally blank.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\r\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\r\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\r\n\r\n  // '\\x00' is a valid character, but various debuggers don't like it.\r\n  // So we'll insert a junk entry to avoid generating a null character.\r\n  lineArray[0] = '';\r\n\r\n  /**\r\n   * Split a text into an array of strings.  Reduce the texts to a string of\r\n   * hashes where each Unicode character represents one line.\r\n   * Modifies linearray and linehash through being a closure.\r\n   * @param {string} text String to encode.\r\n   * @return {string} Encoded string.\r\n   * @private\r\n   */\r\n  function diff_linesToCharsMunge_(text) {\r\n    var chars = '';\r\n    // Walk the text, pulling out a substring for each line.\r\n    // text.split('\\n') would would temporarily double our memory footprint.\r\n    // Modifying text would create many large strings to garbage collect.\r\n    var lineStart = 0;\r\n    var lineEnd = -1;\r\n    // Keeping our own length variable is faster than looking it up.\r\n    var lineArrayLength = lineArray.length;\r\n    while (lineEnd < text.length - 1) {\r\n      lineEnd = text.indexOf('\\n', lineStart);\r\n      if (lineEnd == -1) {\r\n        lineEnd = text.length - 1;\r\n      }\r\n      var line = text.substring(lineStart, lineEnd + 1);\r\n      lineStart = lineEnd + 1;\r\n\r\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\r\n          (lineHash[line] !== undefined)) {\r\n        chars += String.fromCharCode(lineHash[line]);\r\n      } else {\r\n        chars += String.fromCharCode(lineArrayLength);\r\n        lineHash[line] = lineArrayLength;\r\n        lineArray[lineArrayLength++] = line;\r\n      }\r\n    }\r\n    return chars;\r\n  }\r\n\r\n  var chars1 = diff_linesToCharsMunge_(text1);\r\n  var chars2 = diff_linesToCharsMunge_(text2);\r\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\r\n};\r\n\r\n\r\n/**\r\n * Rehydrate the text in a diff from a string of line hashes to real lines of\r\n * text.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @param {!Array.<string>} lineArray Array of unique strings.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var chars = diffs[x][1];\r\n    var text = [];\r\n    for (var y = 0; y < chars.length; y++) {\r\n      text[y] = lineArray[chars.charCodeAt(y)];\r\n    }\r\n    diffs[x][1] = text.join('');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Determine the common prefix of two strings.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the start of each\r\n *     string.\r\n */\r\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\r\n  // Quick check for common null cases.\r\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\r\n    return 0;\r\n  }\r\n  // Binary search.\r\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n  var pointermin = 0;\r\n  var pointermax = Math.min(text1.length, text2.length);\r\n  var pointermid = pointermax;\r\n  var pointerstart = 0;\r\n  while (pointermin < pointermid) {\r\n    if (text1.substring(pointerstart, pointermid) ==\r\n        text2.substring(pointerstart, pointermid)) {\r\n      pointermin = pointermid;\r\n      pointerstart = pointermin;\r\n    } else {\r\n      pointermax = pointermid;\r\n    }\r\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n  }\r\n  return pointermid;\r\n};\r\n\r\n\r\n/**\r\n * Determine the common suffix of two strings.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the end of each string.\r\n */\r\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\r\n  // Quick check for common null cases.\r\n  if (!text1 || !text2 ||\r\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\r\n    return 0;\r\n  }\r\n  // Binary search.\r\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n  var pointermin = 0;\r\n  var pointermax = Math.min(text1.length, text2.length);\r\n  var pointermid = pointermax;\r\n  var pointerend = 0;\r\n  while (pointermin < pointermid) {\r\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\r\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\r\n      pointermin = pointermid;\r\n      pointerend = pointermin;\r\n    } else {\r\n      pointermax = pointermid;\r\n    }\r\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n  }\r\n  return pointermid;\r\n};\r\n\r\n\r\n/**\r\n * Determine if the suffix of one string is the prefix of another.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the end of the first\r\n *     string and the start of the second string.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\r\n  // Cache the text lengths to prevent multiple calls.\r\n  var text1_length = text1.length;\r\n  var text2_length = text2.length;\r\n  // Eliminate the null case.\r\n  if (text1_length == 0 || text2_length == 0) {\r\n    return 0;\r\n  }\r\n  // Truncate the longer string.\r\n  if (text1_length > text2_length) {\r\n    text1 = text1.substring(text1_length - text2_length);\r\n  } else if (text1_length < text2_length) {\r\n    text2 = text2.substring(0, text1_length);\r\n  }\r\n  var text_length = Math.min(text1_length, text2_length);\r\n  // Quick check for the worst case.\r\n  if (text1 == text2) {\r\n    return text_length;\r\n  }\r\n\r\n  // Start by looking for a single character match\r\n  // and increase length until no match is found.\r\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\r\n  var best = 0;\r\n  var length = 1;\r\n  while (true) {\r\n    var pattern = text1.substring(text_length - length);\r\n    var found = text2.indexOf(pattern);\r\n    if (found == -1) {\r\n      return best;\r\n    }\r\n    length += found;\r\n    if (found == 0 || text1.substring(text_length - length) ==\r\n        text2.substring(0, length)) {\r\n      best = length;\r\n      length++;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Do the two texts share a substring which is at least half the length of the\r\n * longer text?\r\n * This speedup can produce non-minimal diffs.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {Array.<string>} Five element Array, containing the prefix of\r\n *     text1, the suffix of text1, the prefix of text2, the suffix of\r\n *     text2 and the common middle.  Or null if there was no match.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\r\n  if (this.Diff_Timeout <= 0) {\r\n    // Don't risk returning a non-optimal diff if we have unlimited time.\r\n    return null;\r\n  }\r\n  var longtext = text1.length > text2.length ? text1 : text2;\r\n  var shorttext = text1.length > text2.length ? text2 : text1;\r\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\r\n    return null;  // Pointless.\r\n  }\r\n  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n  /**\r\n   * Does a substring of shorttext exist within longtext such that the substring\r\n   * is at least half the length of longtext?\r\n   * Closure, but does not reference any external variables.\r\n   * @param {string} longtext Longer string.\r\n   * @param {string} shorttext Shorter string.\r\n   * @param {number} i Start index of quarter length substring within longtext.\r\n   * @return {Array.<string>} Five element Array, containing the prefix of\r\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\r\n   *     of shorttext and the common middle.  Or null if there was no match.\r\n   * @private\r\n   */\r\n  function diff_halfMatchI_(longtext, shorttext, i) {\r\n    // Start with a 1/4 length substring at position i as a seed.\r\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\r\n    var j = -1;\r\n    var best_common = '';\r\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\r\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\r\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\r\n                                               shorttext.substring(j));\r\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\r\n                                               shorttext.substring(0, j));\r\n      if (best_common.length < suffixLength + prefixLength) {\r\n        best_common = shorttext.substring(j - suffixLength, j) +\r\n            shorttext.substring(j, j + prefixLength);\r\n        best_longtext_a = longtext.substring(0, i - suffixLength);\r\n        best_longtext_b = longtext.substring(i + prefixLength);\r\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\r\n        best_shorttext_b = shorttext.substring(j + prefixLength);\r\n      }\r\n    }\r\n    if (best_common.length * 2 >= longtext.length) {\r\n      return [best_longtext_a, best_longtext_b,\r\n              best_shorttext_a, best_shorttext_b, best_common];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // First check if the second quarter is the seed for a half-match.\r\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\r\n                             Math.ceil(longtext.length / 4));\r\n  // Check again based on the third quarter.\r\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\r\n                             Math.ceil(longtext.length / 2));\r\n  var hm;\r\n  if (!hm1 && !hm2) {\r\n    return null;\r\n  } else if (!hm2) {\r\n    hm = hm1;\r\n  } else if (!hm1) {\r\n    hm = hm2;\r\n  } else {\r\n    // Both matched.  Select the longest.\r\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\r\n  }\r\n\r\n  // A half-match was found, sort out the return data.\r\n  var text1_a, text1_b, text2_a, text2_b;\r\n  if (text1.length > text2.length) {\r\n    text1_a = hm[0];\r\n    text1_b = hm[1];\r\n    text2_a = hm[2];\r\n    text2_b = hm[3];\r\n  } else {\r\n    text2_a = hm[0];\r\n    text2_b = hm[1];\r\n    text1_a = hm[2];\r\n    text1_b = hm[3];\r\n  }\r\n  var mid_common = hm[4];\r\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\r\n};\r\n\r\n\r\n/**\r\n * Reduce the number of edits by eliminating semantically trivial equalities.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\r\n  var changes = false;\r\n  var equalities = [];  // Stack of indices where equalities are found.\r\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n  /** @type {?string} */\r\n  var lastequality = null;\r\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n  var pointer = 0;  // Index of current position.\r\n  // Number of characters that changed prior to the equality.\r\n  var length_insertions1 = 0;\r\n  var length_deletions1 = 0;\r\n  // Number of characters that changed after the equality.\r\n  var length_insertions2 = 0;\r\n  var length_deletions2 = 0;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n      equalities[equalitiesLength++] = pointer;\r\n      length_insertions1 = length_insertions2;\r\n      length_deletions1 = length_deletions2;\r\n      length_insertions2 = 0;\r\n      length_deletions2 = 0;\r\n      lastequality = diffs[pointer][1];\r\n    } else {  // An insertion or deletion.\r\n      if (diffs[pointer][0] == DIFF_INSERT) {\r\n        length_insertions2 += diffs[pointer][1].length;\r\n      } else {\r\n        length_deletions2 += diffs[pointer][1].length;\r\n      }\r\n      // Eliminate an equality that is smaller or equal to the edits on both\r\n      // sides of it.\r\n      if (lastequality && (lastequality.length <=\r\n          Math.max(length_insertions1, length_deletions1)) &&\r\n          (lastequality.length <= Math.max(length_insertions2,\r\n                                           length_deletions2))) {\r\n        // Duplicate record.\r\n        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                     [DIFF_DELETE, lastequality]);\r\n        // Change second copy to insert.\r\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n        // Throw away the equality we just deleted.\r\n        equalitiesLength--;\r\n        // Throw away the previous equality (it needs to be reevaluated).\r\n        equalitiesLength--;\r\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\r\n        length_insertions1 = 0;  // Reset the counters.\r\n        length_deletions1 = 0;\r\n        length_insertions2 = 0;\r\n        length_deletions2 = 0;\r\n        lastequality = null;\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n\r\n  // Normalize the diff.\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n  this.diff_cleanupSemanticLossless(diffs);\r\n\r\n  // Find any overlaps between deletions and insertions.\r\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\r\n  //   -> <del>abc</del>xxx<ins>def</ins>\r\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\r\n  //   -> <ins>def</ins>xxx<del>abc</del>\r\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\r\n  pointer = 1;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\r\n        diffs[pointer][0] == DIFF_INSERT) {\r\n      var deletion = diffs[pointer - 1][1];\r\n      var insertion = diffs[pointer][1];\r\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\r\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\r\n      if (overlap_length1 >= overlap_length2) {\r\n        if (overlap_length1 >= deletion.length / 2 ||\r\n            overlap_length1 >= insertion.length / 2) {\r\n          // Overlap found.  Insert an equality and trim the surrounding edits.\r\n          diffs.splice(pointer, 0,\r\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\r\n          diffs[pointer - 1][1] =\r\n              deletion.substring(0, deletion.length - overlap_length1);\r\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\r\n          pointer++;\r\n        }\r\n      } else {\r\n        if (overlap_length2 >= deletion.length / 2 ||\r\n            overlap_length2 >= insertion.length / 2) {\r\n          // Reverse overlap found.\r\n          // Insert an equality and swap and trim the surrounding edits.\r\n          diffs.splice(pointer, 0,\r\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\r\n          diffs[pointer - 1][0] = DIFF_INSERT;\r\n          diffs[pointer - 1][1] =\r\n              insertion.substring(0, insertion.length - overlap_length2);\r\n          diffs[pointer + 1][0] = DIFF_DELETE;\r\n          diffs[pointer + 1][1] =\r\n              deletion.substring(overlap_length2);\r\n          pointer++;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n    pointer++;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Look for single edits surrounded on both sides by equalities\r\n * which can be shifted sideways to align the edit to a word boundary.\r\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\r\n  /**\r\n   * Given two strings, compute a score representing whether the internal\r\n   * boundary falls on logical boundaries.\r\n   * Scores range from 6 (best) to 0 (worst).\r\n   * Closure, but does not reference any external variables.\r\n   * @param {string} one First string.\r\n   * @param {string} two Second string.\r\n   * @return {number} The score.\r\n   * @private\r\n   */\r\n  function diff_cleanupSemanticScore_(one, two) {\r\n    if (!one || !two) {\r\n      // Edges are the best.\r\n      return 6;\r\n    }\r\n\r\n    // Each port of this function behaves slightly differently due to\r\n    // subtle differences in each language's definition of things like\r\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\r\n    // the choice has been made to use each language's native features\r\n    // rather than force total conformity.\r\n    var char1 = one.charAt(one.length - 1);\r\n    var char2 = two.charAt(0);\r\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\r\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\r\n    var whitespace1 = nonAlphaNumeric1 &&\r\n        char1.match(diff_match_patch.whitespaceRegex_);\r\n    var whitespace2 = nonAlphaNumeric2 &&\r\n        char2.match(diff_match_patch.whitespaceRegex_);\r\n    var lineBreak1 = whitespace1 &&\r\n        char1.match(diff_match_patch.linebreakRegex_);\r\n    var lineBreak2 = whitespace2 &&\r\n        char2.match(diff_match_patch.linebreakRegex_);\r\n    var blankLine1 = lineBreak1 &&\r\n        one.match(diff_match_patch.blanklineEndRegex_);\r\n    var blankLine2 = lineBreak2 &&\r\n        two.match(diff_match_patch.blanklineStartRegex_);\r\n\r\n    if (blankLine1 || blankLine2) {\r\n      // Five points for blank lines.\r\n      return 5;\r\n    } else if (lineBreak1 || lineBreak2) {\r\n      // Four points for line breaks.\r\n      return 4;\r\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\r\n      // Three points for end of sentences.\r\n      return 3;\r\n    } else if (whitespace1 || whitespace2) {\r\n      // Two points for whitespace.\r\n      return 2;\r\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\r\n      // One point for non-alphanumeric.\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  var pointer = 1;\r\n  // Intentionally ignore the first and last element (don't need checking).\r\n  while (pointer < diffs.length - 1) {\r\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n      // This is a single edit surrounded by equalities.\r\n      var equality1 = diffs[pointer - 1][1];\r\n      var edit = diffs[pointer][1];\r\n      var equality2 = diffs[pointer + 1][1];\r\n\r\n      // First, shift the edit as far left as possible.\r\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\r\n      if (commonOffset) {\r\n        var commonString = edit.substring(edit.length - commonOffset);\r\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\r\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\r\n        equality2 = commonString + equality2;\r\n      }\r\n\r\n      // Second, step character by character right, looking for the best fit.\r\n      var bestEquality1 = equality1;\r\n      var bestEdit = edit;\r\n      var bestEquality2 = equality2;\r\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\r\n          diff_cleanupSemanticScore_(edit, equality2);\r\n      while (edit.charAt(0) === equality2.charAt(0)) {\r\n        equality1 += edit.charAt(0);\r\n        edit = edit.substring(1) + equality2.charAt(0);\r\n        equality2 = equality2.substring(1);\r\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\r\n            diff_cleanupSemanticScore_(edit, equality2);\r\n        // The >= encourages trailing rather than leading whitespace on edits.\r\n        if (score >= bestScore) {\r\n          bestScore = score;\r\n          bestEquality1 = equality1;\r\n          bestEdit = edit;\r\n          bestEquality2 = equality2;\r\n        }\r\n      }\r\n\r\n      if (diffs[pointer - 1][1] != bestEquality1) {\r\n        // We have an improvement, save it back to the diff.\r\n        if (bestEquality1) {\r\n          diffs[pointer - 1][1] = bestEquality1;\r\n        } else {\r\n          diffs.splice(pointer - 1, 1);\r\n          pointer--;\r\n        }\r\n        diffs[pointer][1] = bestEdit;\r\n        if (bestEquality2) {\r\n          diffs[pointer + 1][1] = bestEquality2;\r\n        } else {\r\n          diffs.splice(pointer + 1, 1);\r\n          pointer--;\r\n        }\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n};\r\n\r\n// Define some regex patterns for matching boundaries.\r\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\r\ndiff_match_patch.whitespaceRegex_ = /\\s/;\r\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\r\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\r\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\r\n\r\n/**\r\n * Reduce the number of edits by eliminating operationally trivial equalities.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\r\n  var changes = false;\r\n  var equalities = [];  // Stack of indices where equalities are found.\r\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n  /** @type {?string} */\r\n  var lastequality = null;\r\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n  var pointer = 0;  // Index of current position.\r\n  // Is there an insertion operation before the last equality.\r\n  var pre_ins = false;\r\n  // Is there a deletion operation before the last equality.\r\n  var pre_del = false;\r\n  // Is there an insertion operation after the last equality.\r\n  var post_ins = false;\r\n  // Is there a deletion operation after the last equality.\r\n  var post_del = false;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\r\n          (post_ins || post_del)) {\r\n        // Candidate found.\r\n        equalities[equalitiesLength++] = pointer;\r\n        pre_ins = post_ins;\r\n        pre_del = post_del;\r\n        lastequality = diffs[pointer][1];\r\n      } else {\r\n        // Not a candidate, and can never become one.\r\n        equalitiesLength = 0;\r\n        lastequality = null;\r\n      }\r\n      post_ins = post_del = false;\r\n    } else {  // An insertion or deletion.\r\n      if (diffs[pointer][0] == DIFF_DELETE) {\r\n        post_del = true;\r\n      } else {\r\n        post_ins = true;\r\n      }\r\n      /*\r\n       * Five types to be split:\r\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\r\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\r\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\r\n       * <ins>A</del>X<ins>C</ins><del>D</del>\r\n       * <ins>A</ins><del>B</del>X<del>C</del>\r\n       */\r\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\r\n                           ((lastequality.length < this.Diff_EditCost / 2) &&\r\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\r\n        // Duplicate record.\r\n        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                     [DIFF_DELETE, lastequality]);\r\n        // Change second copy to insert.\r\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n        equalitiesLength--;  // Throw away the equality we just deleted;\r\n        lastequality = null;\r\n        if (pre_ins && pre_del) {\r\n          // No changes made which could affect previous entry, keep going.\r\n          post_ins = post_del = true;\r\n          equalitiesLength = 0;\r\n        } else {\r\n          equalitiesLength--;  // Throw away the previous equality.\r\n          pointer = equalitiesLength > 0 ?\r\n              equalities[equalitiesLength - 1] : -1;\r\n          post_ins = post_del = false;\r\n        }\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Reorder and merge like edit sections.  Merge equalities.\r\n * Any edit section can move as long as it doesn't cross an equality.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\r\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\r\n  var pointer = 0;\r\n  var count_delete = 0;\r\n  var count_insert = 0;\r\n  var text_delete = '';\r\n  var text_insert = '';\r\n  var commonlength;\r\n  while (pointer < diffs.length) {\r\n    switch (diffs[pointer][0]) {\r\n      case DIFF_INSERT:\r\n        count_insert++;\r\n        text_insert += diffs[pointer][1];\r\n        pointer++;\r\n        break;\r\n      case DIFF_DELETE:\r\n        count_delete++;\r\n        text_delete += diffs[pointer][1];\r\n        pointer++;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // Upon reaching an equality, check for prior redundancies.\r\n        if (count_delete + count_insert > 1) {\r\n          if (count_delete !== 0 && count_insert !== 0) {\r\n            // Factor out any common prefixies.\r\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\r\n            if (commonlength !== 0) {\r\n              if ((pointer - count_delete - count_insert) > 0 &&\r\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\r\n                  DIFF_EQUAL) {\r\n                diffs[pointer - count_delete - count_insert - 1][1] +=\r\n                    text_insert.substring(0, commonlength);\r\n              } else {\r\n                diffs.splice(0, 0, [DIFF_EQUAL,\r\n                                    text_insert.substring(0, commonlength)]);\r\n                pointer++;\r\n              }\r\n              text_insert = text_insert.substring(commonlength);\r\n              text_delete = text_delete.substring(commonlength);\r\n            }\r\n            // Factor out any common suffixies.\r\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\r\n            if (commonlength !== 0) {\r\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\r\n                  commonlength) + diffs[pointer][1];\r\n              text_insert = text_insert.substring(0, text_insert.length -\r\n                  commonlength);\r\n              text_delete = text_delete.substring(0, text_delete.length -\r\n                  commonlength);\r\n            }\r\n          }\r\n          // Delete the offending records and add the merged ones.\r\n          if (count_delete === 0) {\r\n            diffs.splice(pointer - count_insert,\r\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\r\n          } else if (count_insert === 0) {\r\n            diffs.splice(pointer - count_delete,\r\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\r\n          } else {\r\n            diffs.splice(pointer - count_delete - count_insert,\r\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\r\n                [DIFF_INSERT, text_insert]);\r\n          }\r\n          pointer = pointer - count_delete - count_insert +\r\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\r\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\r\n          // Merge this equality with the previous one.\r\n          diffs[pointer - 1][1] += diffs[pointer][1];\r\n          diffs.splice(pointer, 1);\r\n        } else {\r\n          pointer++;\r\n        }\r\n        count_insert = 0;\r\n        count_delete = 0;\r\n        text_delete = '';\r\n        text_insert = '';\r\n        break;\r\n    }\r\n  }\r\n  if (diffs[diffs.length - 1][1] === '') {\r\n    diffs.pop();  // Remove the dummy entry at the end.\r\n  }\r\n\r\n  // Second pass: look for single edits surrounded on both sides by equalities\r\n  // which can be shifted sideways to eliminate an equality.\r\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\r\n  var changes = false;\r\n  pointer = 1;\r\n  // Intentionally ignore the first and last element (don't need checking).\r\n  while (pointer < diffs.length - 1) {\r\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n      // This is a single edit surrounded by equalities.\r\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\r\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\r\n        // Shift the edit over the previous equality.\r\n        diffs[pointer][1] = diffs[pointer - 1][1] +\r\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\r\n                                        diffs[pointer - 1][1].length);\r\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\r\n        diffs.splice(pointer - 1, 1);\r\n        changes = true;\r\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\r\n          diffs[pointer + 1][1]) {\r\n        // Shift the edit over the next equality.\r\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\r\n        diffs[pointer][1] =\r\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\r\n            diffs[pointer + 1][1];\r\n        diffs.splice(pointer + 1, 1);\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n  // If shifts were made, the diff needs reordering and another shift sweep.\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * loc is a location in text1, compute and return the equivalent location in\r\n * text2.\r\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @param {number} loc Location within text1.\r\n * @return {number} Location within text2.\r\n */\r\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\r\n  var chars1 = 0;\r\n  var chars2 = 0;\r\n  var last_chars1 = 0;\r\n  var last_chars2 = 0;\r\n  var x;\r\n  for (x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\r\n      chars1 += diffs[x][1].length;\r\n    }\r\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\r\n      chars2 += diffs[x][1].length;\r\n    }\r\n    if (chars1 > loc) {  // Overshot the location.\r\n      break;\r\n    }\r\n    last_chars1 = chars1;\r\n    last_chars2 = chars2;\r\n  }\r\n  // Was the location was deleted?\r\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\r\n    return last_chars2;\r\n  }\r\n  // Add the remaining character length.\r\n  return last_chars2 + (loc - last_chars1);\r\n};\r\n\r\n\r\n/**\r\n * Convert a diff array into a pretty HTML report.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} HTML representation.\r\n */\r\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\r\n  var html = [];\r\n  var pattern_amp = /&/g;\r\n  var pattern_lt = /</g;\r\n  var pattern_gt = />/g;\r\n  var pattern_para = /\\n/g;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\r\n    var data = diffs[x][1];  // Text of change.\r\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\r\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\r\n    switch (op) {\r\n      case DIFF_INSERT:\r\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\r\n        break;\r\n      case DIFF_DELETE:\r\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\r\n        break;\r\n      case DIFF_EQUAL:\r\n        html[x] = '<span>' + text + '</span>';\r\n        break;\r\n    }\r\n  }\r\n  return html.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute and return the source text (all equalities and deletions).\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Source text.\r\n */\r\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_INSERT) {\r\n      text[x] = diffs[x][1];\r\n    }\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute and return the destination text (all equalities and insertions).\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Destination text.\r\n */\r\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_DELETE) {\r\n      text[x] = diffs[x][1];\r\n    }\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute the Levenshtein distance; the number of inserted, deleted or\r\n * substituted characters.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {number} Number of changes.\r\n */\r\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\r\n  var levenshtein = 0;\r\n  var insertions = 0;\r\n  var deletions = 0;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var op = diffs[x][0];\r\n    var data = diffs[x][1];\r\n    switch (op) {\r\n      case DIFF_INSERT:\r\n        insertions += data.length;\r\n        break;\r\n      case DIFF_DELETE:\r\n        deletions += data.length;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // A deletion and an insertion is one substitution.\r\n        levenshtein += Math.max(insertions, deletions);\r\n        insertions = 0;\r\n        deletions = 0;\r\n        break;\r\n    }\r\n  }\r\n  levenshtein += Math.max(insertions, deletions);\r\n  return levenshtein;\r\n};\r\n\r\n\r\n/**\r\n * Crush the diff into an encoded string which describes the operations\r\n * required to transform text1 into text2.\r\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\r\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Delta text.\r\n */\r\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    switch (diffs[x][0]) {\r\n      case DIFF_INSERT:\r\n        text[x] = '+' + encodeURI(diffs[x][1]);\r\n        break;\r\n      case DIFF_DELETE:\r\n        text[x] = '-' + diffs[x][1].length;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        text[x] = '=' + diffs[x][1].length;\r\n        break;\r\n    }\r\n  }\r\n  return text.join('\\t').replace(/%20/g, ' ');\r\n};\r\n\r\n\r\n/**\r\n * Given the original text1, and an encoded string which describes the\r\n * operations required to transform text1 into text2, compute the full diff.\r\n * @param {string} text1 Source string for the diff.\r\n * @param {string} delta Delta text.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @throws {!Error} If invalid input.\r\n */\r\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\r\n  var diffs = [];\r\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\r\n  var pointer = 0;  // Cursor in text1\r\n  var tokens = delta.split(/\\t/g);\r\n  for (var x = 0; x < tokens.length; x++) {\r\n    // Each token begins with a one character parameter which specifies the\r\n    // operation of this token (delete, insert, equality).\r\n    var param = tokens[x].substring(1);\r\n    switch (tokens[x].charAt(0)) {\r\n      case '+':\r\n        try {\r\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\r\n        } catch (ex) {\r\n          // Malformed URI sequence.\r\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\r\n        }\r\n        break;\r\n      case '-':\r\n        // Fall through.\r\n      case '=':\r\n        var n = parseInt(param, 10);\r\n        if (isNaN(n) || n < 0) {\r\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\r\n        }\r\n        var text = text1.substring(pointer, pointer += n);\r\n        if (tokens[x].charAt(0) == '=') {\r\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\r\n        } else {\r\n          diffs[diffsLength++] = [DIFF_DELETE, text];\r\n        }\r\n        break;\r\n      default:\r\n        // Blank tokens are ok (from a trailing \\t).\r\n        // Anything else is an error.\r\n        if (tokens[x]) {\r\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\r\n                          tokens[x]);\r\n        }\r\n    }\r\n  }\r\n  if (pointer != text1.length) {\r\n    throw new Error('Delta length (' + pointer +\r\n        ') does not equal source text length (' + text1.length + ').');\r\n  }\r\n  return diffs;\r\n};\r\n\r\n\r\n//  MATCH FUNCTIONS\r\n\r\n\r\n/**\r\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\r\n * @param {string} text The text to search.\r\n * @param {string} pattern The pattern to search for.\r\n * @param {number} loc The location to search around.\r\n * @return {number} Best match index or -1.\r\n */\r\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\r\n  // Check for null inputs.\r\n  if (text == null || pattern == null || loc == null) {\r\n    throw new Error('Null input. (match_main)');\r\n  }\r\n\r\n  loc = Math.max(0, Math.min(loc, text.length));\r\n  if (text == pattern) {\r\n    // Shortcut (potentially not guaranteed by the algorithm)\r\n    return 0;\r\n  } else if (!text.length) {\r\n    // Nothing to match.\r\n    return -1;\r\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\r\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\r\n    return loc;\r\n  } else {\r\n    // Do a fuzzy compare.\r\n    return this.match_bitap_(text, pattern, loc);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\r\n * Bitap algorithm.\r\n * @param {string} text The text to search.\r\n * @param {string} pattern The pattern to search for.\r\n * @param {number} loc The location to search around.\r\n * @return {number} Best match index or -1.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\r\n  if (pattern.length > this.Match_MaxBits) {\r\n    throw new Error('Pattern too long for this browser.');\r\n  }\r\n\r\n  // Initialise the alphabet.\r\n  var s = this.match_alphabet_(pattern);\r\n\r\n  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n  /**\r\n   * Compute and return the score for a match with e errors and x location.\r\n   * Accesses loc and pattern through being a closure.\r\n   * @param {number} e Number of errors in match.\r\n   * @param {number} x Location of match.\r\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\r\n   * @private\r\n   */\r\n  function match_bitapScore_(e, x) {\r\n    var accuracy = e / pattern.length;\r\n    var proximity = Math.abs(loc - x);\r\n    if (!dmp.Match_Distance) {\r\n      // Dodge divide by zero error.\r\n      return proximity ? 1.0 : accuracy;\r\n    }\r\n    return accuracy + (proximity / dmp.Match_Distance);\r\n  }\r\n\r\n  // Highest score beyond which we give up.\r\n  var score_threshold = this.Match_Threshold;\r\n  // Is there a nearby exact match? (speedup)\r\n  var best_loc = text.indexOf(pattern, loc);\r\n  if (best_loc != -1) {\r\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n    // What about in the other direction? (speedup)\r\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\r\n    if (best_loc != -1) {\r\n      score_threshold =\r\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n    }\r\n  }\r\n\r\n  // Initialise the bit arrays.\r\n  var matchmask = 1 << (pattern.length - 1);\r\n  best_loc = -1;\r\n\r\n  var bin_min, bin_mid;\r\n  var bin_max = pattern.length + text.length;\r\n  var last_rd;\r\n  for (var d = 0; d < pattern.length; d++) {\r\n    // Scan for the best match; each iteration allows for one more error.\r\n    // Run a binary search to determine how far from 'loc' we can stray at this\r\n    // error level.\r\n    bin_min = 0;\r\n    bin_mid = bin_max;\r\n    while (bin_min < bin_mid) {\r\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\r\n        bin_min = bin_mid;\r\n      } else {\r\n        bin_max = bin_mid;\r\n      }\r\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\r\n    }\r\n    // Use the result from this iteration as the maximum for the next.\r\n    bin_max = bin_mid;\r\n    var start = Math.max(1, loc - bin_mid + 1);\r\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\r\n\r\n    var rd = Array(finish + 2);\r\n    rd[finish + 1] = (1 << d) - 1;\r\n    for (var j = finish; j >= start; j--) {\r\n      // The alphabet (s) is a sparse hash, so the following line generates\r\n      // warnings.\r\n      var charMatch = s[text.charAt(j - 1)];\r\n      if (d === 0) {  // First pass: exact match.\r\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\r\n      } else {  // Subsequent passes: fuzzy match.\r\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\r\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\r\n                last_rd[j + 1];\r\n      }\r\n      if (rd[j] & matchmask) {\r\n        var score = match_bitapScore_(d, j - 1);\r\n        // This match will almost certainly be better than any existing match.\r\n        // But check anyway.\r\n        if (score <= score_threshold) {\r\n          // Told you so.\r\n          score_threshold = score;\r\n          best_loc = j - 1;\r\n          if (best_loc > loc) {\r\n            // When passing loc, don't exceed our current distance from loc.\r\n            start = Math.max(1, 2 * loc - best_loc);\r\n          } else {\r\n            // Already passed loc, downhill from here on in.\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // No hope for a (better) match at greater error levels.\r\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\r\n      break;\r\n    }\r\n    last_rd = rd;\r\n  }\r\n  return best_loc;\r\n};\r\n\r\n\r\n/**\r\n * Initialise the alphabet for the Bitap algorithm.\r\n * @param {string} pattern The text to encode.\r\n * @return {!Object} Hash of character locations.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\r\n  var s = {};\r\n  for (var i = 0; i < pattern.length; i++) {\r\n    s[pattern.charAt(i)] = 0;\r\n  }\r\n  for (var i = 0; i < pattern.length; i++) {\r\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\r\n  }\r\n  return s;\r\n};\r\n\r\n\r\n//  PATCH FUNCTIONS\r\n\r\n\r\n/**\r\n * Increase the context until it is unique,\r\n * but don't let the pattern expand beyond Match_MaxBits.\r\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\r\n * @param {string} text Source text.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\r\n  if (text.length == 0) {\r\n    return;\r\n  }\r\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\r\n  var padding = 0;\r\n\r\n  // Look for the first and last matches of pattern in text.  If two different\r\n  // matches are found, increase the pattern length.\r\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\r\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\r\n         this.Patch_Margin) {\r\n    padding += this.Patch_Margin;\r\n    pattern = text.substring(patch.start2 - padding,\r\n                             patch.start2 + patch.length1 + padding);\r\n  }\r\n  // Add one chunk for good luck.\r\n  padding += this.Patch_Margin;\r\n\r\n  // Add the prefix.\r\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\r\n  if (prefix) {\r\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\r\n  }\r\n  // Add the suffix.\r\n  var suffix = text.substring(patch.start2 + patch.length1,\r\n                              patch.start2 + patch.length1 + padding);\r\n  if (suffix) {\r\n    patch.diffs.push([DIFF_EQUAL, suffix]);\r\n  }\r\n\r\n  // Roll back the start points.\r\n  patch.start1 -= prefix.length;\r\n  patch.start2 -= prefix.length;\r\n  // Extend the lengths.\r\n  patch.length1 += prefix.length + suffix.length;\r\n  patch.length2 += prefix.length + suffix.length;\r\n};\r\n\r\n\r\n/**\r\n * Compute a list of patches to turn text1 into text2.\r\n * Use diffs if provided, otherwise compute it ourselves.\r\n * There are four ways to call this function, depending on what data is\r\n * available to the caller:\r\n * Method 1:\r\n * a = text1, b = text2\r\n * Method 2:\r\n * a = diffs\r\n * Method 3 (optimal):\r\n * a = text1, b = diffs\r\n * Method 4 (deprecated, use method 3):\r\n * a = text1, b = text2, c = diffs\r\n *\r\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\r\n * Array of diff tuples for text1 to text2 (method 2).\r\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\r\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\r\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\r\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\r\n  var text1, diffs;\r\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 1: text1, text2\r\n    // Compute diffs from text1 and text2.\r\n    text1 = /** @type {string} */(a);\r\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\r\n    if (diffs.length > 2) {\r\n      this.diff_cleanupSemantic(diffs);\r\n      this.diff_cleanupEfficiency(diffs);\r\n    }\r\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 2: diffs\r\n    // Compute text1 from diffs.\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\r\n    text1 = this.diff_text1(diffs);\r\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 3: text1, diffs\r\n    text1 = /** @type {string} */(a);\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\r\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n      opt_c && typeof opt_c == 'object') {\r\n    // Method 4: text1, text2, diffs\r\n    // text2 is not used.\r\n    text1 = /** @type {string} */(a);\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\r\n  } else {\r\n    throw new Error('Unknown call format to patch_make.');\r\n  }\r\n\r\n  if (diffs.length === 0) {\r\n    return [];  // Get rid of the null case.\r\n  }\r\n  var patches = [];\r\n  var patch = new diff_match_patch.patch_obj();\r\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\r\n  var char_count1 = 0;  // Number of characters into the text1 string.\r\n  var char_count2 = 0;  // Number of characters into the text2 string.\r\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\r\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\r\n  // context info.\r\n  var prepatch_text = text1;\r\n  var postpatch_text = text1;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var diff_type = diffs[x][0];\r\n    var diff_text = diffs[x][1];\r\n\r\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\r\n      // A new patch starts here.\r\n      patch.start1 = char_count1;\r\n      patch.start2 = char_count2;\r\n    }\r\n\r\n    switch (diff_type) {\r\n      case DIFF_INSERT:\r\n        patch.diffs[patchDiffLength++] = diffs[x];\r\n        patch.length2 += diff_text.length;\r\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\r\n                         postpatch_text.substring(char_count2);\r\n        break;\r\n      case DIFF_DELETE:\r\n        patch.length1 += diff_text.length;\r\n        patch.diffs[patchDiffLength++] = diffs[x];\r\n        postpatch_text = postpatch_text.substring(0, char_count2) +\r\n                         postpatch_text.substring(char_count2 +\r\n                             diff_text.length);\r\n        break;\r\n      case DIFF_EQUAL:\r\n        if (diff_text.length <= 2 * this.Patch_Margin &&\r\n            patchDiffLength && diffs.length != x + 1) {\r\n          // Small equality inside a patch.\r\n          patch.diffs[patchDiffLength++] = diffs[x];\r\n          patch.length1 += diff_text.length;\r\n          patch.length2 += diff_text.length;\r\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\r\n          // Time for a new patch.\r\n          if (patchDiffLength) {\r\n            this.patch_addContext_(patch, prepatch_text);\r\n            patches.push(patch);\r\n            patch = new diff_match_patch.patch_obj();\r\n            patchDiffLength = 0;\r\n            // Unlike Unidiff, our patch lists have a rolling context.\r\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\r\n            // Update prepatch text & pos to reflect the application of the\r\n            // just completed patch.\r\n            prepatch_text = postpatch_text;\r\n            char_count1 = char_count2;\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Update the current character count.\r\n    if (diff_type !== DIFF_INSERT) {\r\n      char_count1 += diff_text.length;\r\n    }\r\n    if (diff_type !== DIFF_DELETE) {\r\n      char_count2 += diff_text.length;\r\n    }\r\n  }\r\n  // Pick up the leftover patch if not empty.\r\n  if (patchDiffLength) {\r\n    this.patch_addContext_(patch, prepatch_text);\r\n    patches.push(patch);\r\n  }\r\n\r\n  return patches;\r\n};\r\n\r\n\r\n/**\r\n * Given an array of patches, return another array that is identical.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\r\n  // Making deep copies is hard in JavaScript.\r\n  var patchesCopy = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    var patch = patches[x];\r\n    var patchCopy = new diff_match_patch.patch_obj();\r\n    patchCopy.diffs = [];\r\n    for (var y = 0; y < patch.diffs.length; y++) {\r\n      patchCopy.diffs[y] = patch.diffs[y].slice();\r\n    }\r\n    patchCopy.start1 = patch.start1;\r\n    patchCopy.start2 = patch.start2;\r\n    patchCopy.length1 = patch.length1;\r\n    patchCopy.length2 = patch.length2;\r\n    patchesCopy[x] = patchCopy;\r\n  }\r\n  return patchesCopy;\r\n};\r\n\r\n\r\n/**\r\n * Merge a set of patches onto the text.  Return a patched text, as well\r\n * as a list of true/false values indicating which patches were applied.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @param {string} text Old text.\r\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\r\n *      new text and an array of boolean values.\r\n */\r\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\r\n  if (patches.length == 0) {\r\n    return [text, []];\r\n  }\r\n\r\n  // Deep copy the patches so that no changes are made to originals.\r\n  patches = this.patch_deepCopy(patches);\r\n\r\n  var nullPadding = this.patch_addPadding(patches);\r\n  text = nullPadding + text + nullPadding;\r\n\r\n  this.patch_splitMax(patches);\r\n  // delta keeps track of the offset between the expected and actual location\r\n  // of the previous patch.  If there are patches expected at positions 10 and\r\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\r\n  // has an effective expected position of 22.\r\n  var delta = 0;\r\n  var results = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    var expected_loc = patches[x].start2 + delta;\r\n    var text1 = this.diff_text1(patches[x].diffs);\r\n    var start_loc;\r\n    var end_loc = -1;\r\n    if (text1.length > this.Match_MaxBits) {\r\n      // patch_splitMax will only provide an oversized pattern in the case of\r\n      // a monster delete.\r\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\r\n                                  expected_loc);\r\n      if (start_loc != -1) {\r\n        end_loc = this.match_main(text,\r\n            text1.substring(text1.length - this.Match_MaxBits),\r\n            expected_loc + text1.length - this.Match_MaxBits);\r\n        if (end_loc == -1 || start_loc >= end_loc) {\r\n          // Can't find valid trailing context.  Drop this patch.\r\n          start_loc = -1;\r\n        }\r\n      }\r\n    } else {\r\n      start_loc = this.match_main(text, text1, expected_loc);\r\n    }\r\n    if (start_loc == -1) {\r\n      // No match found.  :(\r\n      results[x] = false;\r\n      // Subtract the delta for this failed patch from subsequent patches.\r\n      delta -= patches[x].length2 - patches[x].length1;\r\n    } else {\r\n      // Found a match.  :)\r\n      results[x] = true;\r\n      delta = start_loc - expected_loc;\r\n      var text2;\r\n      if (end_loc == -1) {\r\n        text2 = text.substring(start_loc, start_loc + text1.length);\r\n      } else {\r\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\r\n      }\r\n      if (text1 == text2) {\r\n        // Perfect match, just shove the replacement text in.\r\n        text = text.substring(0, start_loc) +\r\n               this.diff_text2(patches[x].diffs) +\r\n               text.substring(start_loc + text1.length);\r\n      } else {\r\n        // Imperfect match.  Run a diff to get a framework of equivalent\r\n        // indices.\r\n        var diffs = this.diff_main(text1, text2, false);\r\n        if (text1.length > this.Match_MaxBits &&\r\n            this.diff_levenshtein(diffs) / text1.length >\r\n            this.Patch_DeleteThreshold) {\r\n          // The end points match, but the content is unacceptably bad.\r\n          results[x] = false;\r\n        } else {\r\n          this.diff_cleanupSemanticLossless(diffs);\r\n          var index1 = 0;\r\n          var index2;\r\n          for (var y = 0; y < patches[x].diffs.length; y++) {\r\n            var mod = patches[x].diffs[y];\r\n            if (mod[0] !== DIFF_EQUAL) {\r\n              index2 = this.diff_xIndex(diffs, index1);\r\n            }\r\n            if (mod[0] === DIFF_INSERT) {  // Insertion\r\n              text = text.substring(0, start_loc + index2) + mod[1] +\r\n                     text.substring(start_loc + index2);\r\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\r\n              text = text.substring(0, start_loc + index2) +\r\n                     text.substring(start_loc + this.diff_xIndex(diffs,\r\n                         index1 + mod[1].length));\r\n            }\r\n            if (mod[0] !== DIFF_DELETE) {\r\n              index1 += mod[1].length;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Strip the padding off.\r\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\r\n  return [text, results];\r\n};\r\n\r\n\r\n/**\r\n * Add some padding on text start and end so that edges can match something.\r\n * Intended to be called only from within patch_apply.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {string} The padding string added to each side.\r\n */\r\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\r\n  var paddingLength = this.Patch_Margin;\r\n  var nullPadding = '';\r\n  for (var x = 1; x <= paddingLength; x++) {\r\n    nullPadding += String.fromCharCode(x);\r\n  }\r\n\r\n  // Bump all the patches forward.\r\n  for (var x = 0; x < patches.length; x++) {\r\n    patches[x].start1 += paddingLength;\r\n    patches[x].start2 += paddingLength;\r\n  }\r\n\r\n  // Add some padding on start of first diff.\r\n  var patch = patches[0];\r\n  var diffs = patch.diffs;\r\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\r\n    // Add nullPadding equality.\r\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\r\n    patch.start1 -= paddingLength;  // Should be 0.\r\n    patch.start2 -= paddingLength;  // Should be 0.\r\n    patch.length1 += paddingLength;\r\n    patch.length2 += paddingLength;\r\n  } else if (paddingLength > diffs[0][1].length) {\r\n    // Grow first equality.\r\n    var extraLength = paddingLength - diffs[0][1].length;\r\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\r\n    patch.start1 -= extraLength;\r\n    patch.start2 -= extraLength;\r\n    patch.length1 += extraLength;\r\n    patch.length2 += extraLength;\r\n  }\r\n\r\n  // Add some padding on end of last diff.\r\n  patch = patches[patches.length - 1];\r\n  diffs = patch.diffs;\r\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\r\n    // Add nullPadding equality.\r\n    diffs.push([DIFF_EQUAL, nullPadding]);\r\n    patch.length1 += paddingLength;\r\n    patch.length2 += paddingLength;\r\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\r\n    // Grow last equality.\r\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\r\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\r\n    patch.length1 += extraLength;\r\n    patch.length2 += extraLength;\r\n  }\r\n\r\n  return nullPadding;\r\n};\r\n\r\n\r\n/**\r\n * Look through the patches and break up any which are longer than the maximum\r\n * limit of the match algorithm.\r\n * Intended to be called only from within patch_apply.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\r\n  var patch_size = this.Match_MaxBits;\r\n  for (var x = 0; x < patches.length; x++) {\r\n    if (patches[x].length1 <= patch_size) {\r\n      continue;\r\n    }\r\n    var bigpatch = patches[x];\r\n    // Remove the big old patch.\r\n    patches.splice(x--, 1);\r\n    var start1 = bigpatch.start1;\r\n    var start2 = bigpatch.start2;\r\n    var precontext = '';\r\n    while (bigpatch.diffs.length !== 0) {\r\n      // Create one of several smaller patches.\r\n      var patch = new diff_match_patch.patch_obj();\r\n      var empty = true;\r\n      patch.start1 = start1 - precontext.length;\r\n      patch.start2 = start2 - precontext.length;\r\n      if (precontext !== '') {\r\n        patch.length1 = patch.length2 = precontext.length;\r\n        patch.diffs.push([DIFF_EQUAL, precontext]);\r\n      }\r\n      while (bigpatch.diffs.length !== 0 &&\r\n             patch.length1 < patch_size - this.Patch_Margin) {\r\n        var diff_type = bigpatch.diffs[0][0];\r\n        var diff_text = bigpatch.diffs[0][1];\r\n        if (diff_type === DIFF_INSERT) {\r\n          // Insertions are harmless.\r\n          patch.length2 += diff_text.length;\r\n          start2 += diff_text.length;\r\n          patch.diffs.push(bigpatch.diffs.shift());\r\n          empty = false;\r\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\r\n                   patch.diffs[0][0] == DIFF_EQUAL &&\r\n                   diff_text.length > 2 * patch_size) {\r\n          // This is a large deletion.  Let it pass in one chunk.\r\n          patch.length1 += diff_text.length;\r\n          start1 += diff_text.length;\r\n          empty = false;\r\n          patch.diffs.push([diff_type, diff_text]);\r\n          bigpatch.diffs.shift();\r\n        } else {\r\n          // Deletion or equality.  Only take as much as we can stomach.\r\n          diff_text = diff_text.substring(0,\r\n              patch_size - patch.length1 - this.Patch_Margin);\r\n          patch.length1 += diff_text.length;\r\n          start1 += diff_text.length;\r\n          if (diff_type === DIFF_EQUAL) {\r\n            patch.length2 += diff_text.length;\r\n            start2 += diff_text.length;\r\n          } else {\r\n            empty = false;\r\n          }\r\n          patch.diffs.push([diff_type, diff_text]);\r\n          if (diff_text == bigpatch.diffs[0][1]) {\r\n            bigpatch.diffs.shift();\r\n          } else {\r\n            bigpatch.diffs[0][1] =\r\n                bigpatch.diffs[0][1].substring(diff_text.length);\r\n          }\r\n        }\r\n      }\r\n      // Compute the head context for the next patch.\r\n      precontext = this.diff_text2(patch.diffs);\r\n      precontext =\r\n          precontext.substring(precontext.length - this.Patch_Margin);\r\n      // Append the end context for this patch.\r\n      var postcontext = this.diff_text1(bigpatch.diffs)\r\n                            .substring(0, this.Patch_Margin);\r\n      if (postcontext !== '') {\r\n        patch.length1 += postcontext.length;\r\n        patch.length2 += postcontext.length;\r\n        if (patch.diffs.length !== 0 &&\r\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\r\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\r\n        } else {\r\n          patch.diffs.push([DIFF_EQUAL, postcontext]);\r\n        }\r\n      }\r\n      if (!empty) {\r\n        patches.splice(++x, 0, patch);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Take a list of patches and return a textual representation.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {string} Text representation of patches.\r\n */\r\ndiff_match_patch.prototype.patch_toText = function(patches) {\r\n  var text = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    text[x] = patches[x];\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Parse a textual representation of patches and return a list of Patch objects.\r\n * @param {string} textline Text representation of patches.\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n * @throws {!Error} If invalid input.\r\n */\r\ndiff_match_patch.prototype.patch_fromText = function(textline) {\r\n  var patches = [];\r\n  if (!textline) {\r\n    return patches;\r\n  }\r\n  var text = textline.split('\\n');\r\n  var textPointer = 0;\r\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\r\n  while (textPointer < text.length) {\r\n    var m = text[textPointer].match(patchHeader);\r\n    if (!m) {\r\n      throw new Error('Invalid patch string: ' + text[textPointer]);\r\n    }\r\n    var patch = new diff_match_patch.patch_obj();\r\n    patches.push(patch);\r\n    patch.start1 = parseInt(m[1], 10);\r\n    if (m[2] === '') {\r\n      patch.start1--;\r\n      patch.length1 = 1;\r\n    } else if (m[2] == '0') {\r\n      patch.length1 = 0;\r\n    } else {\r\n      patch.start1--;\r\n      patch.length1 = parseInt(m[2], 10);\r\n    }\r\n\r\n    patch.start2 = parseInt(m[3], 10);\r\n    if (m[4] === '') {\r\n      patch.start2--;\r\n      patch.length2 = 1;\r\n    } else if (m[4] == '0') {\r\n      patch.length2 = 0;\r\n    } else {\r\n      patch.start2--;\r\n      patch.length2 = parseInt(m[4], 10);\r\n    }\r\n    textPointer++;\r\n\r\n    while (textPointer < text.length) {\r\n      var sign = text[textPointer].charAt(0);\r\n      try {\r\n        var line = decodeURI(text[textPointer].substring(1));\r\n      } catch (ex) {\r\n        // Malformed URI sequence.\r\n        throw new Error('Illegal escape in patch_fromText: ' + line);\r\n      }\r\n      if (sign == '-') {\r\n        // Deletion.\r\n        patch.diffs.push([DIFF_DELETE, line]);\r\n      } else if (sign == '+') {\r\n        // Insertion.\r\n        patch.diffs.push([DIFF_INSERT, line]);\r\n      } else if (sign == ' ') {\r\n        // Minor equality.\r\n        patch.diffs.push([DIFF_EQUAL, line]);\r\n      } else if (sign == '@') {\r\n        // Start of next patch.\r\n        break;\r\n      } else if (sign === '') {\r\n        // Blank line?  Whatever.\r\n      } else {\r\n        // WTF?\r\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\r\n      }\r\n      textPointer++;\r\n    }\r\n  }\r\n  return patches;\r\n};\r\n\r\n\r\n/**\r\n * Class representing one patch operation.\r\n * @constructor\r\n */\r\ndiff_match_patch.patch_obj = function() {\r\n  /** @type {!Array.<!diff_match_patch.Diff>} */\r\n  this.diffs = [];\r\n  /** @type {?number} */\r\n  this.start1 = null;\r\n  /** @type {?number} */\r\n  this.start2 = null;\r\n  /** @type {number} */\r\n  this.length1 = 0;\r\n  /** @type {number} */\r\n  this.length2 = 0;\r\n};\r\n\r\n\r\n/**\r\n * Emmulate GNU diff's format.\r\n * Header: @@ -382,8 +481,9 @@\r\n * Indicies are printed as 1-based, not 0-based.\r\n * @return {string} The GNU diff string.\r\n */\r\ndiff_match_patch.patch_obj.prototype.toString = function() {\r\n  var coords1, coords2;\r\n  if (this.length1 === 0) {\r\n    coords1 = this.start1 + ',0';\r\n  } else if (this.length1 == 1) {\r\n    coords1 = this.start1 + 1;\r\n  } else {\r\n    coords1 = (this.start1 + 1) + ',' + this.length1;\r\n  }\r\n  if (this.length2 === 0) {\r\n    coords2 = this.start2 + ',0';\r\n  } else if (this.length2 == 1) {\r\n    coords2 = this.start2 + 1;\r\n  } else {\r\n    coords2 = (this.start2 + 1) + ',' + this.length2;\r\n  }\r\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\r\n  var op;\r\n  // Escape the body of the patch with %xx notation.\r\n  for (var x = 0; x < this.diffs.length; x++) {\r\n    switch (this.diffs[x][0]) {\r\n      case DIFF_INSERT:\r\n        op = '+';\r\n        break;\r\n      case DIFF_DELETE:\r\n        op = '-';\r\n        break;\r\n      case DIFF_EQUAL:\r\n        op = ' ';\r\n        break;\r\n    }\r\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\r\n  }\r\n  return text.join('').replace(/%20/g, ' ');\r\n};\r\n\r\n\r\n// The following export code was added by @ForbesLindesay\r\nmodule.exports = diff_match_patch;\r\nmodule.exports['diff_match_patch'] = diff_match_patch;\r\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\r\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\r\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@terrencecrowley/ot-editutil/~/diff-match-patch/index.js\n// module id = 4\n// module chunks = 0","module.exports = React;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"React\"\n// module id = 5\n// module chunks = 0","module.exports = ReactDOM;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ReactDOM\"\n// module id = 6\n// module chunks = 0","// TODO:\n//\tEn Passant\n//\tCastling\n//\tNo Castling under jeopardy\n//\tStalemate due to endless repetition\n\nexport const Empty: number = 0;\nexport const Pawn: number = 1;\nexport const Knight: number = 2;\nexport const Bishop: number = 4;\nexport const Rook: number = 8;\nexport const Queen: number = 16;\nexport const King: number = 32;\nexport const Black: number = 64;\nexport const White: number = 128;\n\nlet InitialBoard: number[] = [\n\tWhite|Rook,White|Knight,White|Bishop,White|King,White|Queen,White|Bishop,White|Knight,White|Rook,\n\tWhite|Pawn,White|Pawn,White|Pawn,White|Pawn,White|Pawn,White|Pawn,White|Pawn,White|Pawn,\n\tEmpty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,\n\tEmpty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,\n\tEmpty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,\n\tEmpty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,\n\tBlack|Pawn,Black|Pawn,Black|Pawn,Black|Pawn,Black|Pawn,Black|Pawn,Black|Pawn,Black|Pawn,\n\tBlack|Rook,Black|Knight,Black|Bishop,Black|King,Black|Queen,Black|Bishop,Black|Knight,Black|Rook\n];\n\n// TODO: Can't encode Castle and En Passant\nexport type Move = [number, number, number, number]; // StartPos, PieceValue, EndPos, PreviousPiece\n\nfunction indexRC(r: number, c: number): number { return r*8+c; }\nfunction invertColor(c: number) { return c == White ? Black : White; }\n\nexport class Board\n{\n\tSquares: number[];\n\tCaptured: number[];\n\tMoves: Move[];\n\tCastled: number;\t// Flags for Black and White\n\tSelected: number;\n\tTargets: number[];\n\n\tconstructor()\n\t\t{\n\t\t\tthis.Squares = new Array(64);\n\t\t\tfor (let i: number = 0; i < 64; i++) this.Squares[i] = InitialBoard[i];\n\t\t\tthis.Moves = [];\n\t\t\tthis.Castled = 0; // Or in Black or White\n\t\t\tthis.Selected = -1;\n\t\t\tthis.Targets = [];\n\t\t}\n\n\tget selected(): number\n\t\t{\n\t\t\treturn this.Selected;\n\t\t}\n\n\tget targets(): number[]\n\t\t{\n\t\t\treturn this.Targets;\n\t\t}\n\n\tisTargeted(n: number): boolean\n\t\t{\n\t\t\tfor (let i: number = 0; i < this.Targets.length; i++) if (this.Targets[i] == n) return true;\n\t\t\treturn false;\n\t\t}\n\n\tsetSelected(n: number)\n\t\t{\n\t\t\tif (this.colorAt(n) == this.whoseMove())\n\t\t\t\tthis.Selected = n;\n\t\t\telse\n\t\t\t\tthis.Selected = -1;\n\n\t\t\tif (this.Selected == -1)\n\t\t\t\tthis.Targets = [];\n\t\t\telse\n\t\t\t\tthis.Targets = this.getLegalMoves(this.Selected);\n\t\t}\n\n\tcolorAt(n: number)\n\t\t{\n\t\t\treturn (n >= 0 && n < 64) ? (this.Squares[n] & (Black|White)) : 0;\n\t\t}\n\n\tpieceAt(n: number)\n\t\t{\n\t\t\treturn (n >= 0 && n < 64) ? (this.Squares[n] & (~(Black|White))) : Empty;\n\t\t}\n\n\tfindPiece(piece: number): number\n\t\t{\n\t\t\tfor (let i: number = 0; i < 64; i++)\n\t\t\t\tif (this.Squares[i] == piece)\n\t\t\t\t\treturn i;\n\t\t\treturn -1;\n\t\t}\n\n\tisPathEmpty(start: number, end: number): boolean\n\t\t{\n\t\t\tlet sRow = Math.floor(start / 8);\n\t\t\tlet sCol = start % 8;\n\t\t\tlet eRow = Math.floor(end / 8);\n\t\t\tlet eCol = end % 8;\n\t\t\tlet rIncr = sRow == eRow ? 0 : (sRow > eRow ? -1 : 1);\n\t\t\tlet cIncr = sCol == eCol ? 0 : (sCol > eCol ? -1 : 1);\n\t\t\tfor (sRow += rIncr, sCol += cIncr; sRow != eRow; sRow += rIncr, sCol += cIncr)\n\t\t\t\tif (this.Squares[indexRC(sRow, sCol)] != Empty) return false;\n\t\t\treturn true;\n\t\t}\n\n\tgetLegalSingle(eRow: number, eCol: number, sColor: number, moves: number[]): boolean\n\t\t{\n\t\t\tif (eRow < 0 || eRow > 7 || eCol < 0 || eCol > 7) return true;\n\n\t\t\tlet end: number = indexRC(eRow, eCol);\n\t\t\tlet endPiece: number = this.Squares[end];\n\t\t\tif (endPiece == Empty)\n\t\t\t{\n\t\t\t\tmoves.push(end);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((endPiece & sColor) == 0)\n\t\t\t\t\tmoves.push(end);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\tgetLegalSequence(sRow: number, sCol: number, incrRow: number, incrCol: number, sColor: number, moves: number[]): void\n\t\t{\n\t\t\tlet eRow: number = sRow + incrRow;\n\t\t\tlet eCol: number = sCol + incrCol;\n\n\t\t\tfor (; eRow >= 0 && eRow < 8 && eCol >= 0 && eCol < 8; eRow += incrRow, eCol += incrCol)\n\t\t\t\tif (this.getLegalSingle(eRow, eCol, sColor, moves))\n\t\t\t\t\tbreak;\n\t\t}\n\n\tgetLegalMovesUnfiltered(start: number, moves: number[] = []): number[]\n\t\t{\n\t\t\tlet piece: number = this.Squares[start];\n\t\t\tlet color: number = piece & (Black|White);\n\t\t\tlet iColor: number = invertColor(color);\n\t\t\tpiece -= color;\n\t\t\tlet sRow: number = Math.floor(start / 8);\n\t\t\tlet sCol: number = start % 8;\n\t\t\tlet incr: number;\n\t\t\tlet bAtInit: boolean;\n\n\t\t\tswitch (piece)\n\t\t\t{\n\t\t\t\tcase Empty:\n\t\t\t\t\tbreak;\n\t\t\t\tcase Pawn:\n\t\t\t\t\t{\n\t\t\t\t\t\tincr = color == White ? 1 : -1;\n\t\t\t\t\t\tbAtInit = color == White ? sRow == 1 : sRow == 6;\n\t\t\t\t\t\tlet colorMove1: number = this.colorAt(indexRC(sRow+incr, sCol));\n\t\t\t\t\t\tlet colorMove2: number = this.colorAt(indexRC(sRow+(2*incr), sCol));\n\t\t\t\t\t\tlet colorAttack1: number = this.colorAt(indexRC(sRow+incr, sCol+1));\n\t\t\t\t\t\tlet colorAttack2: number = this.colorAt(indexRC(sRow+incr, sCol-1));\n\t\t\t\t\t\tif (colorMove1 == Empty)\n\t\t\t\t\t\t\tmoves.push(indexRC(sRow+incr, sCol));\n\t\t\t\t\t\tif (bAtInit && colorMove1 == Empty && colorMove2 == Empty)\n\t\t\t\t\t\t\tmoves.push(indexRC(sRow+(2*incr), sCol));\n\t\t\t\t\t\tif (colorAttack1 == iColor)\n\t\t\t\t\t\t\tmoves.push(indexRC(sRow+incr, sCol+1));\n\t\t\t\t\t\tif (colorAttack2 == iColor)\n\t\t\t\t\t\t\tmoves.push(indexRC(sRow+incr, sCol-1));\n\t\t\t\t\t\t// TODO: En Passant\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Knight:\n\t\t\t\t\tthis.getLegalSingle(sRow+2, sCol+1, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow-2, sCol+1, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow+2, sCol-1, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow-2, sCol-1, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow+1, sCol+2, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow-1, sCol+2, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow+1, sCol-2, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow-1, sCol-2, color, moves);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Bishop:\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, 1, 1, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, -1, -1, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, -1, 1, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, 1, -1, color, moves);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Rook:\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, 1, 0, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, 0, 1, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, -1, 0, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, 0, -1, color, moves);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Queen:\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, 1, 1, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, -1, -1, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, -1, 1, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, 1, -1, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, 1, 0, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, 0, 1, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, -1, 0, color, moves);\n\t\t\t\t\tthis.getLegalSequence(sRow, sCol, 0, -1, color, moves);\n\t\t\t\t\tbreak;\n\t\t\t\tcase King:\n\t\t\t\t\tthis.getLegalSingle(sRow+1, sCol+1, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow+1, sCol+0, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow+1, sCol-1, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow+0, sCol+1, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow+0, sCol-1, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow-1, sCol+1, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow-1, sCol+0, color, moves);\n\t\t\t\t\tthis.getLegalSingle(sRow-1, sCol-1, color, moves);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn moves;\n\t\t}\n\n\tgetLegalMoves(start: number, moves: number[] = []): number[]\n\t\t{\n\t\t\tlet color: number = this.colorAt(start);\n\t\t\tlet potentialMoves: number[] = [];\n\t\t\tthis.getLegalMovesUnfiltered(start, potentialMoves);\n\n\t\t\t// Now filter out moves that leave me in check\n\t\t\tfor (let i: number = 0; i < potentialMoves.length; i++)\n\t\t\t{\n\t\t\t\tthis.move(start, potentialMoves[i]);\n\t\t\t\tif (! this.isCheck(color))\n\t\t\t\t\tmoves.push(potentialMoves[i]);\n\t\t\t\tthis.undo();\n\t\t\t}\n\n\t\t\treturn moves;\n\t\t}\n\n\tisMoveLegal(start: number, end: number): boolean\n\t\t{\n\t\t\t// Need to be on board\n\t\t\tif (start < 0 || start >= 64) return false;\n\n\t\t\t// Need to stay on board\n\t\t\tif (end < 0 || end >= 64) return false;\n\n\t\t\t// Need to actually move\n\t\t\tif (start == end) return false;\n\n\t\t\t// Needs to be a piece at starting square\n\t\t\tif (this.Squares[start] == Empty) return false;\n\n\t\t\tlet moves: number[] = this.getLegalMoves(start);\n\t\t\tfor (let i: number = 0; i < moves.length; i++)\n\t\t\t\tif (moves[i] == end)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\tmove(start: number, end: number): void\n\t\t{\n\t\t\tlet m: Move = [ start, this.Squares[start], end, this.Squares[end] ];\n\t\t\tthis.Squares[end] = this.Squares[start];\n\t\t\tthis.Squares[start] = Empty;\n\t\t\tthis.Moves.push(m);\n\t\t}\n\n\tundo(): void\n\t\t{\n\t\t\tlet m: Move = this.Moves[this.Moves.length-1];\n\t\t\tthis.Moves.splice(this.Moves.length-1);\n\t\t\tthis.Squares[m[0]] = m[1];\n\t\t\tthis.Squares[m[2]] = m[3];\n\t\t}\n\n\tcastle(color: number, kingside: boolean): void\n\t\t{\n\t\t}\n\n\tisCheck(color: number): boolean\n\t\t{\n\t\t\tlet iColor: number = invertColor(color);\n\t\t\tlet n: number = this.findPiece(color|King);\n\t\t\tfor (let i: number = 0; i < 64; i++)\n\t\t\t\tif (this.colorAt(i) == iColor)\n\t\t\t\t{\n\t\t\t\t\tlet moves: number[] = this.getLegalMovesUnfiltered(i);\n\t\t\t\t\tfor (let j: number = 0; j < moves.length; j++)\n\t\t\t\t\t\tif (moves[j] == n)\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\tisMate(): number // Black and/or White returned\n\t\t{\n\t\t\tlet color: number = 0;\n\n\t\t\tlet n: number = this.findPiece(Black|King);\n\t\t\tlet moves: number[] = this.getLegalMoves(n);\n\t\t\tif (moves.length == 0) color |= Black;\n\n\t\t\tn = this.findPiece(White|King);\n\t\t\tmoves = this.getLegalMoves(n);\n\t\t\tif (moves.length == 0) color |= White;\n\n\t\t\treturn color;\n\t\t}\n\n\tisStalemate(): boolean\n\t\t{\n\t\t\tlet color: number = this.whoseMove();\n\t\t\tlet moves: number[] = [];\n\t\t\tfor (let i: number = 0; i < 64 && moves.length == 0; i++)\n\t\t\t\tif (this.Squares[i] | color)\n\t\t\t\t\tthis.getLegalMoves(i, moves);\n\t\t\treturn moves.length == 0;\n\t\t}\n\n\twhoseMove(): number\n\t\t{\n\t\t\treturn ((this.Moves.length % 2) == 0) ? White : Black;\n\t\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/board.ts","import * as React from \"react\";\nimport { NavBar } from \"./navbar\";\nimport { BoardView } from \"./boardview\";\nimport { Message } from \"./message\";\nimport { Chat } from \"./chat\";\nimport * as Board from \"../board\";\n\nexport interface AppProps {\n\t\tname: string, \n\t\turl: string,\n\t\tstatus: string,\n\t\tisChatOn: boolean,\n\t\tnChatSeen: number,\n\t\tchatArray: any,\n\t\tclientID: string,\n\t\tusers: any,\n\t\tboard: Board.Board,\n\t\tnewCB: () => void,\n\t\tchatCB: () => void,\n\t\tsubmitChatCB: (s: string) => void,\n\t\tcaptureElementCB: (el: any) => void,\n\t\tcontentChangeCB: (s: string, ss: number, se: number) => void,\n\t\tnameChangeCB: (s: string) => void,\n\t\tclickSquare: (id: number) => void\n\t\t}\n\nexport class ReactApp extends React.Component<AppProps, {}> {\n\trender()\n\t\t{\n\t\t\tlet nChatUnseen: number = this.props.isChatOn ? 0 : this.props.chatArray.length - this.props.nChatSeen;\n\t\t\tlet cmpNav: any = <NavBar url={this.props.url} name={this.props.name} nameChangeCB={this.props.nameChangeCB} newCB={this.props.newCB} chatCB={this.props.chatCB} isChatOn={this.props.isChatOn} nChatUnseen={nChatUnseen} board={this.props.board}/>;\n\t\t\tlet cmpBoard: any = <BoardView board={this.props.board} clickSquare={this.props.clickSquare} />;\n\t\t\tlet cmpChat: any = <Chat submitChatCB={this.props.submitChatCB} clientID={this.props.clientID} users={this.props.users} chatArray={this.props.chatArray} />;\n\t\t\tlet cmpMessage: any = <Message status={this.props.status} />;\n\n\t\t\tif (this.props.isChatOn)\n\t\t\t\treturn (\n\t\t\t\t\t<div className=\"wrapper\">\n\t\t\t\t\t\t<div className=\"header\">\n\t\t\t\t\t\t{cmpNav}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"content inarow\">\n\t\t\t\t\t\t{cmpBoard}\n\t\t\t\t\t\t{cmpChat}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"footer\">\n\t\t\t\t\t\t{cmpMessage}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t);\n\t\t\telse\n\t\t\t\treturn (\n\t\t\t\t\t<div className=\"wrapper\">\n\t\t\t\t\t\t<div className=\"header\">\n\t\t\t\t\t\t{cmpNav}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"content\">\n\t\t\t\t\t\t{cmpBoard}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"footer\">\n\t\t\t\t\t\t{cmpMessage}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t);\n\t\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/app.tsx","import * as $ from \"jquery\";\nimport * as React from \"react\";\nimport * as Board from \"../board\";\n\nexport interface NavProps {\n\turl: string,\n\tname: string,\n\tisChatOn: boolean,\n\tnChatUnseen: number,\n\tnameChangeCB: (s: string) => void,\n\tnewCB: () => void,\n\tchatCB: () => void,\n\tboard: Board.Board\n\t}\n\nexport interface NavState {\n\tusername: string\n\t}\n\nexport class NavBar extends React.Component<NavProps, NavState> {\n\tconstructor(props: any)\n\t\t{\n\t\t\tsuper(props);\n\t\t\tthis.handleNew = this.handleNew.bind(this);\n\t\t\tthis.handleShare = this.handleShare.bind(this);\n\t\t\tthis.handleChat = this.handleChat.bind(this);\n\t\t\tthis.handleDismiss = this.handleDismiss.bind(this);\n\t\t\tthis.handleCopyClick = this.handleCopyClick.bind(this);\n\t\t\tthis.handleDisplayName = this.handleDisplayName.bind(this);\n\t\t\tthis.handleSetName = this.handleSetName.bind(this);\n\t\t\tthis.handleChange = this.handleChange.bind(this);\n\t\t\tthis.handleReturn = this.handleReturn.bind(this);\n\t\t\tthis.state = { username: props.name };\n\t\t}\n\n\thandleCopyClick()\n\t\t{\n\t\t\t$('#nav').focus();\n\t\t\t$('#nav').select();\n\t\t\tdocument.execCommand('copy');\n\t\t}\n\n\thandleChange(e: any): void\n\t\t{\n\t\t\tthis.setState( { username: e.target.value } );\n\t\t}\n\n\thandleReturn(e: any): boolean\n\t\t{\n\t\t\tif (e.charCode == 13)\n\t\t\t{\n\t\t\t\treturn this.handleSetName(e);\n\t\t\t}\n\t\t}\n\n\thandleNew(e: any): boolean\n\t\t{\n\t\t\tthis.props.newCB();\n\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\treturn false;\n\t\t}\n\n\thandleChat(e: any): boolean\n\t\t{\n\t\t\tthis.props.chatCB();\n\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\treturn false;\n\t\t}\n\n\thandleShare(e: any): boolean\n\t\t{\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\t$('#popup-share').css('display', 'flex');\n\t\t\t$('#nav').focus();\n\t\t\t$('#nav').select();\n\t\t\tdocument.execCommand('copy');\n\t\t\treturn false;\n\t\t}\n\n\thandleDismiss(e: any): boolean\n\t\t{\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\t$('#popup-share').css('display', 'none');\n\t\t\treturn false;\n\t\t}\n\n\thandleDisplayName(e: any): boolean\n\t\t{\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis.setState({ username: this.props.name });\n\t\t\t$('#popup-user').css('display', 'flex');\n\t\t\t$('#username').focus();\n\t\t\t$('#username').select();\n\t\t\treturn false;\n\t\t}\n\n\thandleSetName(e: any): boolean\n\t\t{\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\t$('#popup-user').css('display', 'none');\n\t\t\tthis.props.nameChangeCB(this.state.username);\n\t\t\treturn false;\n\t\t}\n\n\trender()\n\t\t{\n\t\t\tlet chatString: string = this.props.isChatOn ? \"Hide Chat\" : \"Chat\";\n\t\t\tif (this.props.nChatUnseen > 0)\n\t\t\t\tchatString += \"(\" + String(this.props.nChatUnseen) + \")\";\n\t\t\tlet nameString: string = this.props.name == '' ? \"Set Name\" : this.props.name;\n\t\t\tlet colorString: string = this.props.board.whoseMove() == Board.Black ? \"Black Moves\" : \"White Moves\";\n\t\t\treturn (\n\t\t\t\t<div className=\"headerrow\">\n\t\t\t\t\t<a href=\"/\">Home</a>&nbsp; | &nbsp;<a href=\"#share\" onClick={this.handleShare}>Share</a>&nbsp; | &nbsp;<a href=\"#new\" onClick={this.handleNew}>New</a>&nbsp; | &nbsp;<a href=\"#chat\" onClick={this.handleChat}>{chatString}</a>&nbsp; | &nbsp;<a href=\"#namechange\" onClick={this.handleDisplayName}>{nameString}</a>&nbsp; | &nbsp;{colorString}\n\t\t\t\t\t<div id=\"popup-share\" className=\"popup\">Copy and share this url:<br/>\n\t\t\t\t\t\t<input id=\"nav\" className=\"line\" type=\"text\" value={this.props.url} readOnly={true}/><br/>\n\t\t\t\t\t\t<a href=\"#dismiss\" onClick={this.handleDismiss}>Close</a>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div id=\"popup-user\" className=\"popup\">User:<br/>\n\t\t\t\t\t\t<input id=\"username\" className=\"line\" type=\"text\" value={this.state.username} onChange={this.handleChange} onKeyPress={this.handleReturn} /><br/>\n\t\t\t\t\t\t<a href=\"#dismiss\" onClick={this.handleSetName}>Close</a>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t);\n\t\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/navbar.tsx","import * as React from \"react\";\nimport * as Board from \"../board\";\n\nexport interface BoardProps {\n\tboard: Board.Board,\n\tclickSquare: (id: number) => void\n}\n\nexport interface BoardState { }\n\nlet PieceString: string[] = [];\n\nfunction getPieceString(): string[]\n\t{\n\t\tif (PieceString.length == 0)\n\t\t{\n\t\t\tPieceString[Board.Empty] = \"\";\n\t\t\tPieceString[Board.Pawn] = \"P\";\n\t\t\tPieceString[Board.Knight] = \"N\";\n\t\t\tPieceString[Board.Bishop] = \"B\";\n\t\t\tPieceString[Board.Rook] = \"R\";\n\t\t\tPieceString[Board.Queen] = \"Q\";\n\t\t\tPieceString[Board.King] = \"K\";\n\t\t}\n\t\treturn PieceString;\n\t}\n\nexport class BoardView extends React.Component<BoardProps, BoardState> {\n\tconstructor(props: any)\n\t\t{\n\t\t\tsuper(props);\n\t\t\tthis.handleClick = this.handleClick.bind(this);\n\t\t}\n\n\thandleClick(e: any): boolean\n\t\t{\n\t\t\tthis.props.clickSquare(Number(e.currentTarget.id));\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\treturn false;\n\t\t}\n\n\trender()\n\t\t{\n\t\t\tlet nRows: number = 8;\n\t\t\tlet nCells: number = 8;\n\t\t\tlet rows: any[] = [];\n\t\t\tlet c: number = 0;\n\t\t\tfor (let i: number = 0; i < nRows; i++)\n\t\t\t{\n\t\t\t\tlet row: any[] = [];\n\t\t\t\tfor (let j: number = 0; j < nCells; j++, c++)\n\t\t\t\t{\n\t\t\t\t\tlet piece: number = this.props.board.pieceAt(c);\n\t\t\t\t\tlet color: number = this.props.board.colorAt(c);\n\t\t\t\t\tlet pieceClass: string = (color == Board.White) ? \"whitePiece\" : \"blackPiece\";\n\t\t\t\t\tlet squareClass: string = (i % 2) == (j % 2) ? \"whiteCell\" : \"blackCell\";\n\t\t\t\t\tlet selClass: string = this.props.board.selected == c ? \" selected\" : \"\";\n\t\t\t\t\tlet targetClass: string = this.props.board.isTargeted(c) ? \" targeted\" : \"\";\n\t\t\t\t\tlet classString: string = pieceClass + \" \" + squareClass;\n\t\t\t\t\tlet pieceString = getPieceString()[piece];\n\t\t\t\t\trow[j] = (\n\t\t\t\t\t\t<div onClick={this.handleClick} id={String(c)} key={String(c)} className={classString}>\n\t\t\t\t\t\t\t<table className=\"pieceTable\"><tbody><tr><td className={selClass + targetClass}>&nbsp;{pieceString}&nbsp;</td></tr></tbody></table>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\trows[i] = (\n\t\t\t\t\t<div className=\"row\">\n\t\t\t\t\t{row}\n\t\t\t\t\t</div>\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn (\n\t\t\t\t<div className=\"column\">\n\t\t\t\t{rows}\n\t\t\t\t</div>\n\t\t\t\t);\n\t\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/boardview.tsx","import * as React from \"react\";\n\nexport interface MessageProps { status: string }\n\nexport class Message extends React.Component<MessageProps, {}> {\n\trender()\n\t\t{\n\t\t\treturn ( <div>{this.props.status}</div> );\n\t\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/message.tsx","import * as $ from \"jquery\";\nimport * as React from \"react\";\n\nexport interface ChatProps {\n\tclientID: string,\n\tusers: any,\n\tchatArray: any,\n\tsubmitChatCB: (s: string) => void\n\t}\n\nexport interface ChatState {\n\ttext: string\n\t}\n\nexport class Chat extends React.Component<ChatProps, ChatState> {\n\tconstructor(props: any)\n\t\t{\n\t\t\tsuper(props);\n\t\t\tthis.handleChange = this.handleChange.bind(this);\n\t\t\tthis.handleReturn = this.handleReturn.bind(this);\n\t\t\tthis.state = { text: '' };\n\t\t}\n\n\thandleChange(event: any): void\n\t\t{\n\t\t\tthis.setState( { text: event.target.value } );\n\t\t}\n\n\thandleReturn(event: any): void\n\t\t{\n\t\t\tif (event.charCode == 13)\n\t\t\t{\n\t\t\t\tthis.props.submitChatCB(event.target.value);\n\t\t\t\tthis.setState( { text: '' } );\n\t\t\t}\n\t\t}\n\n\tcomponentDidMount()\n\t\t{\n\t\t\t$('#chat').focus();\n\t\t}\n\n\tcomponentDidUpdate(prevProps: any, prevState: any): void\n\t\t{\n\t\t\t$('#chatbox').scrollTop($('#chatbox')[0].scrollHeight);\n\t\t}\n\n\trender()\n\t\t{\n\t\t\tlet whoMe: string = this.props.clientID;\n\t\t\tlet whoMap: any = this.props.users;\n\t\t\tconst chatHistory = this.props.chatArray.map((chatEntry: any, i: number) => {\n\t\t\t\tlet sWho: string = whoMap[chatEntry[0]];\n\t\t\t\tif (!sWho || sWho == '') sWho = chatEntry[0] == whoMe ? 'me' : 'anon';\n\t\t\t\treturn (\n\t\t\t\t\t<li key={i}>\n\t\t\t\t\t{sWho}: {chatEntry[1]}\n\t\t\t\t\t</li>\n\t\t\t\t);\n\t\t\t\t});\n\t\t\treturn (\n\t\t\t\t<div className=\"chatcontainer\">\n\t\t\t\t\t<div id=\"chatbox\" className=\"chatbox\"><ol>{chatHistory}</ol></div>\n\t\t\t\t\t<input className=\"chatinput\" id=\"chat\" type=\"text\" value={this.state.text} onChange={this.handleChange} onKeyPress={this.handleReturn} />\n\t\t\t\t</div> );\n\t\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/chat.tsx"],"sourceRoot":""}